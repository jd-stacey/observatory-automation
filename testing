# # Basic usage - parse log and write to mirror_telescope.json
# python log_parser.py telescope.log

# # Custom output file
# python log_parser.py telescope.log --output /path/to/custom_mirror.json

# # Just see what would be written without creating file
# python log_parser.py telescope.log --print-only




import argparse
import html
import json
import os
import re
from pathlib import Path
from urllib.parse import urlparse, parse_qs
from datetime import datetime, timezone

ISO_RE = re.compile(r'\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z')

def iso_to_dt(iso_str: str) -> datetime:
    if iso_str.endswith('Z'):
        iso_str = iso_str[:-1] + '+00:00'
    return datetime.fromisoformat(iso_str)

def dt_iso(dt: datetime) -> str:
    return dt.astimezone(timezone.utc).isoformat()

def split_lines(raw_text: str):
    # Unescape HTML entities (&amp;, &#x2F;, etc.) and ensure each timestamp starts a new line
    text = html.unescape(raw_text)
    text = re.sub(r'(?<!\n)(' + ISO_RE.pattern + r'\s*\|)', r'\n\1', text)
    return [ln.strip() for ln in text.splitlines() if ln.strip()]

def colsplit(line: str):
    parts = line.split('|', 4)
    if len(parts) < 5:
        return None
    return tuple(p.strip() for p in parts)  # ts, session, level, component, payload

# ---------- helpers for move ----------
def hhmmss_to_deg(h: float, m: float, s: float) -> float:
    return 15.0 * (abs(h) + m/60.0 + s/3600.0) * (1 if h >= 0 else -1)

def dms_to_deg(d: float, m: float, s: float) -> float:
    sign = -1 if d < 0 else 1
    return sign * (abs(d) + m/60.0 + s/3600.0)

def parse_sexagesimal(s: str):
    a, b, c = [float(x) for x in s.split()]
    return a, b, c


def extract_latest_move(lines):
    """
    Find the latest pwi_http move. Robust to spaces inside RA/Dec values.
    We do NOT try to parse a URL; instead we directly capture ra2000/dec2000.
    """
    # ra: 01 07 13.01   dec: -23 59 47.3 (allow + or -)
    RA_RE  = re.compile(r'ra2000\s*=\s*([0-9]{1,2}\s+[0-9]{1,2}\s+[0-9]+(?:\.[0-9]+)?)', re.IGNORECASE)
    DEC_RE = re.compile(r'dec2000\s*=\s*([+\-]?[0-9]{1,2}\s+[0-9]{1,2}\s+[0-9]+(?:\.[0-9]+)?)', re.IGNORECASE)

    latest_ts = None
    latest = None

    def iso_to_dt(iso_str: str) -> datetime:
        if iso_str.endswith('Z'):
            iso_str = iso_str[:-1] + '+00:00'
        return datetime.fromisoformat(iso_str)

    def dt_iso(dt: datetime) -> str:
        return dt.astimezone(timezone.utc).isoformat()

    def parse_sexagesimal(s: str):
        a, b, c = [float(x) for x in s.split()]
        return a, b, c

    def hhmmss_to_deg(h, m, s):
        return 15.0 * (abs(h) + m/60.0 + s/3600.0) * (1 if h >= 0 else -1)

    def dms_to_deg(d, m, s):
        sign = -1 if d < 0 else 1
        return sign * (abs(d) + m/60.0 + s/3600.0)

    for ln in lines:
        # quick gate: must be pwi_http and mention cmd=move
        if ' pwi_http ' not in ln or 'cmd=' not in ln or 'move' not in ln.lower():
            continue
        parts = ln.split('|', 4)
        if len(parts) < 5:
            continue
        ts_str, _, _, component, payload = [p.strip() for p in parts]
        if component != 'pwi_http':
            continue

        payload_u = html.unescape(payload)

        ra_m  = RA_RE.search(payload_u)
        dec_m = DEC_RE.search(payload_u)
        if not (ra_m and dec_m):
            continue

        ts = iso_to_dt(ts_str)
        if (latest_ts is None) or (ts > latest_ts):
            ra_str  = ra_m.group(1)
            dec_str = dec_m.group(1)
            rh, rm, rs = parse_sexagesimal(ra_str)
            dd, dm, ds = parse_sexagesimal(dec_str)
            latest_ts = ts
            latest = {
                'timestamp': dt_iso(ts),
                'ra_str': ra_str,
                'dec_str': dec_str,
                'ra_deg': hhmmss_to_deg(rh, rm, rs),
                'dec_deg': dms_to_deg(dd, dm, ds),
            }

    return latest


def extract_latest_dome(lines):
    latest_ts = None
    latest = None
    for ln in lines:
        if ' dome ' not in ln and ' emergency ' not in ln:
            continue
        cols = colsplit(ln)
        if not cols:
            continue
        ts_str, _, level, component, payload = cols
        if component not in ('dome', 'emergency'):
            continue
        ts = iso_to_dt(ts_str)
        msg = html.unescape(payload)
        low = msg.lower()

        # Normalize
        if 'weather danger' in low and 'closing' in low:
            status = 'weather_danger_closing'
        elif 'closing both panels' in low:
            status = 'closing_both_panels'
        elif 'close action requested' in low and 'left' in low:
            status = 'close_requested_left'
        elif 'close action requested' in low and 'right' in low:
            status = 'close_requested_right'
        elif 'close action requested' in low:
            status = 'close_requested'
        elif 'opening' in low:
            status = 'opening'
        elif 'opened' in low:
            status = 'opened'
        elif 'closed' in low:
            status = 'closed'
        else:
            status = 'dome_msg'

        if (latest_ts is None) or (ts > latest_ts):
            latest_ts = ts
            latest = {
                'timestamp': dt_iso(ts),
                'status': status,
                'level': level,
                'message': msg,
            }
    return latest

def extract_latest_guider(lines):
    latest_ts = None
    latest_kind = None
    latest_msg = None

    for ln in lines:
        cols = colsplit(ln)
        if not cols:
            continue
        ts_str, _, _, component, payload = cols
        ts = iso_to_dt(ts_str)
        msg = html.unescape(payload)
        low = msg.lower()

        # HTTP stop request
        if component == 'http' and 'stopping guiding loop' in low:
            if (latest_ts is None) or (ts > latest_ts):
                latest_ts = ts
                latest_kind = 'stop_requested'
                latest_msg = msg

        # Status-based guider messages (domains start with 'Guiding')
        if component == 'status' and low.startswith('guiding'):
            kind = None
            if 'starting guiding loop' in low:
                kind = 'started'
            elif 'guiding loop aborted' in low:
                kind = 'aborted'
            elif 'ended' in low:
                kind = 'ended'
            elif 'guiding loop' in low and 'exposing' in low:
                kind = 'loop_activity'
            elif 'guiding to star' in low or 'pull star in' in low:
                kind = 'activity'
            if kind and ((latest_ts is None) or (ts > latest_ts)):
                latest_ts = ts
                latest_kind = kind
                latest_msg = msg

    if latest_ts is None:
        return None
    return {'timestamp': dt_iso(latest_ts), 'status': latest_kind, 'message': latest_msg}


def write_mirror_json(data: dict, output_file: str):
    """Write mirror data to JSON file using atomic write pattern"""
    output_path = Path(output_file)
    temp_path = output_path.with_suffix('.tmp')
    
    try:
        # Write to temporary file first
        with open(temp_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        
        # Atomic rename to final file
        if os.name == 'nt':  # Windows
            # On Windows, need to remove target if it exists
            if output_path.exists():
                output_path.unlink()
        
        temp_path.rename(output_path)
        print(f"Successfully wrote mirror data to: {output_path}")
        
    except Exception as e:
        # Clean up temp file on error
        if temp_path.exists():
            try:
                temp_path.unlink()
            except:
                pass
        raise Exception(f"Failed to write mirror JSON: {e}")


def main():
    ap = argparse.ArgumentParser(description="Parse telescope log and create mirror JSON file")
    ap.add_argument("logfile", help="Log file to parse")
    ap.add_argument("--output", "-o", default="mirror_telescope.json", 
                    help="Output JSON file (default: mirror_telescope.json)")
    ap.add_argument("--print-only", action="store_true",
                    help="Only print to stdout, don't write JSON file")
    args = ap.parse_args()

    try:
        with open(args.logfile, 'r', encoding='utf-8', errors='ignore') as f:
            raw = f.read()
    except FileNotFoundError:
        print(f"ERROR: Log file not found: {args.logfile}")
        return 1
    except Exception as e:
        print(f"ERROR: Failed to read log file: {e}")
        return 1

    lines = split_lines(raw)
    
    if not lines:
        print("WARNING: Log file is empty or has no valid log lines")

    # Extract all the data
    result = {
        'latest_move': extract_latest_move(lines),
        'latest_dome': extract_latest_dome(lines),
        'latest_guider': extract_latest_guider(lines),
        'parse_timestamp': datetime.now(timezone.utc).isoformat(),
        'source_file': str(Path(args.logfile).resolve()),
        'total_lines_parsed': len(lines)
    }

    # Report status
    if result['latest_move']:
        print(f"Found latest move: {result['latest_move']['timestamp']} -> "
              f"RA={result['latest_move']['ra_deg']:.6f}°, Dec={result['latest_move']['dec_deg']:.6f}°")
    else:
        print("No telescope moves found in log")
    
    if result['latest_dome']:
        print(f"Found latest dome status: {result['latest_dome']['status']} at {result['latest_dome']['timestamp']}")
    else:
        print("No dome status found in log")
        
    if result['latest_guider']:
        print(f"Found latest guider status: {result['latest_guider']['status']} at {result['latest_guider']['timestamp']}")
    else:
        print("No guider status found in log")

    # Always print the result for debugging
    if args.print_only:
        print("\nResult:")
        print(json.dumps(result, indent=2))
    else:
        # Write to JSON file
        try:
            write_mirror_json(result, args.output)
        except Exception as e:
            print(f"ERROR: {e}")
            return 1

    return 0


if __name__ == "__main__":
    exit(main())
