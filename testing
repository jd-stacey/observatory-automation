#!/usr/bin/env python3
"""
Emergency Telescope Shutdown Tool
Safely shuts down telescope system after TCU restart or other emergencies.
FIXED: Resolves DLL conflicts with Autoslew startup
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import subprocess
import time
import threading
import logging
import sys
from pathlib import Path
import psutil
import os
from typing import Optional, Dict, Any

# Import your existing drivers (assuming they're in the same directory or Python path)
try:
    from alpaca_telescope import AlpacaTelescopeDriver, AlpacaTelescopeError
    from alpaca_rotator import AlpacaRotatorDriver, AlpacaRotatorError  
    from alpaca_cover import AlpacaCoverDriver, AlpacaCoverError
    DRIVERS_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Could not import drivers: {e}")
    DRIVERS_AVAILABLE = False

class EmergencyShutdownGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Emergency Telescope Shutdown")
        self.root.geometry("700x800")
        self.root.configure(bg='#f0f0f0')
        
        # Make window stay on top initially
        self.root.attributes('-topmost', True)
        
        # Device configurations (from your devices.yaml)
        self.device_configs = {
            'telescope': {
                'address': '127.0.0.1:11111',
                'device_number': 0,
                'settle_time': 2.0
            },
            'rotator': {
                'address': '127.0.0.1:11112', 
                'device_number': 0,
                'settle_time': 0.1,
                'mechanical_limits': {'min_deg': 94.0, 'max_deg': 320.0}
            },
            'cover': {
                'address': '127.0.0.1:11112',
                'device_number': 0,
                'operation_timeout': 30.0,
                'settle_time': 15.0
            }
        }
        
        self.autoslew_path = r"C:\Program Files (x86)\Autoslew\Autoslew.exe"
        
        # Device drivers - Initialize as None to prevent early connections
        self.telescope = None
        self.rotator = None  
        self.cover = None
        
        # GUI state
        self.shutdown_in_progress = False
        self.autoslew_started = False
        self.connections_delayed = True  # NEW: Delay connections until after Autoslew is fully ready
        
        self.setup_logging()
        self.create_widgets()
        self.center_window()
        
    def setup_logging(self):
        """Setup logging to display in GUI"""
        self.log_handler = LogHandler(self)
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[self.log_handler]
        )
        self.logger = logging.getLogger(__name__)
        
    def create_widgets(self):
        """Create the GUI widgets"""
        
        # Title
        title_frame = tk.Frame(self.root, bg='#d32f2f', height=60)
        title_frame.pack(fill='x', padx=5, pady=5)
        title_frame.pack_propagate(False)
        
        title_label = tk.Label(
            title_frame, 
            text="âš ï¸ EMERGENCY TELESCOPE SHUTDOWN âš ï¸", 
            font=('Arial', 14, 'bold'),
            fg='white', 
            bg='#d32f2f'
        )
        title_label.pack(expand=True)
        
        # Warning text
        warning_frame = tk.Frame(self.root, bg='#fff3cd', relief='solid', bd=1)
        warning_frame.pack(fill='x', padx=10, pady=5)
        
        warning_text = tk.Text(
            warning_frame, 
            height=4, 
            bg='#fff3cd', 
            fg='#856404',
            font=('Arial', 10),
            relief='flat',
            wrap='word'
        )
        warning_text.pack(fill='x', padx=10, pady=10)
        warning_text.insert('1.0', 
            "âš ï¸  This tool performs emergency shutdown of telescope systems.\n"
            "âš ï¸  Use only after TCU restart or system failure.\n"
            "âš ï¸  This will STOP rotator, CLOSE covers, PARK telescope, and turn OFF motors.\n"
            "âš ï¸  Multiple confirmations required - do not use during normal operations!")
        warning_text.config(state='disabled')
        
        # Buttons frame
        button_frame = tk.Frame(self.root, bg='#f0f0f0')
        button_frame.pack(fill='x', padx=10, pady=10)
        
        # Start Autoslew button
        self.autoslew_btn = tk.Button(
            button_frame,
            text="1. Start Autoslew & Check Connections",
            command=self.start_autoslew_and_check,
            bg='#4CAF50',
            fg='white',
            font=('Arial', 11, 'bold'),
            height=2
        )
        self.autoslew_btn.pack(fill='x', pady=5)
        
        # Emergency shutdown button (initially disabled)
        self.shutdown_btn = tk.Button(
            button_frame,
            text="2. EMERGENCY SHUTDOWN",
            command=self.confirm_emergency_shutdown,
            bg='#d32f2f',
            fg='white', 
            font=('Arial', 11, 'bold'),
            height=2,
            state='disabled'
        )
        self.shutdown_btn.pack(fill='x', pady=5)
        
        # Exit button
        self.exit_btn = tk.Button(
            button_frame,
            text="Exit",
            command=self.safe_exit,
            bg='#6c757d',
            fg='white',
            font=('Arial', 10)
        )
        self.exit_btn.pack(fill='x', pady=5)
        
        # Status frame
        status_frame = tk.LabelFrame(self.root, text="System Status", bg='#f0f0f0', font=('Arial', 10, 'bold'))
        status_frame.pack(fill='x', padx=10, pady=5)
        
        # Status labels
        self.status_labels = {}
        for device in ['Autoslew', 'Telescope', 'Rotator', 'Cover']:
            frame = tk.Frame(status_frame, bg='#f0f0f0')
            frame.pack(fill='x', padx=5, pady=2)
            
            label = tk.Label(frame, text=f"{device}:", bg='#f0f0f0', font=('Arial', 9))
            label.pack(side='left')
            
            status = tk.Label(frame, text="Not Connected", bg='#f0f0f0', fg='red', font=('Arial', 9, 'bold'))
            status.pack(side='right')
            
            self.status_labels[device] = status
            
        # Log display
        log_frame = tk.LabelFrame(self.root, text="Activity Log", bg='#f0f0f0', font=('Arial', 10, 'bold'))
        log_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.log_display = scrolledtext.ScrolledText(
            log_frame, 
            height=10, 
            bg='black', 
            fg='lime',
            font=('Consolas', 9),
            state='disabled'
        )
        self.log_display.pack(fill='both', expand=True, padx=5, pady=5)
        
        # Progress bar
        self.progress = ttk.Progressbar(self.root, mode='indeterminate')
        self.progress.pack(fill='x', padx=10, pady=5)
        
        self.logger.info("Emergency Shutdown Tool initialized")
        self.logger.info("Click 'Start Autoslew & Check Connections' to begin")
        
    def center_window(self):
        """Center window on screen"""
        self.root.update_idletasks()
        x = (self.root.winfo_screenwidth() // 2) - (self.root.winfo_width() // 2)
        y = (self.root.winfo_screenheight() // 2) - (self.root.winfo_height() // 2)
        self.root.geometry(f"+{x}+{y}")
        
    def update_status(self, device: str, status: str, color: str = 'red'):
        """Update device status display"""
        if device in self.status_labels:
            self.status_labels[device].config(text=status, fg=color)
            
    def is_autoslew_running(self) -> bool:
        """Check if Autoslew is already running"""
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                if 'autoslew' in proc.info['name'].lower():
                    return True
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        return False
        
    def start_autoslew_and_check(self):
        """Start Autoslew and check device connections"""
        if self.shutdown_in_progress:
            return
            
        # Disable button and start progress
        self.autoslew_btn.config(state='disabled')
        self.progress.start()
        
        # Run in separate thread
        thread = threading.Thread(target=self._autoslew_and_check_worker)
        thread.daemon = True
        thread.start()
        
    def _check_alpaca_service_ready(self, address, device_type, device_number):
        """Check if ALPACA service responds without connecting"""
        try:
            import requests
            url = f"http://{address}/api/v1/{device_type}/{device_number}/connected"
            response = requests.get(url, timeout=2)
            return response.status_code == 200
        except:
            return False
            
    def _wait_for_autoslew_full_startup(self):
        """
        CRITICAL FIX: Wait for Autoslew to fully initialize its drivers
        before attempting any Python ASCOM connections
        """
        self.logger.info("Waiting for Autoslew to fully initialize all drivers...")
        
        # Extended wait time to ensure Autoslew has loaded all its DLLs
        # and established hardware connections first
        for i in range(60):  # Up to 60 seconds
            if i % 10 == 0:  # Log every 10 seconds
                self.logger.info(f"Autoslew initialization check... {i}/60 seconds")
            
            # Check if Autoslew HTTP services are responding
            # This indicates Autoslew has finished loading
            try:
                telescope_ready = self._check_alpaca_service_ready("127.0.0.1:11111", "telescope", 0)
                if telescope_ready:
                    # Additional safety wait to ensure DLL initialization is complete
                    self.logger.info("ALPACA service detected - waiting additional 15 seconds for full driver initialization...")
                    time.sleep(15)
                    return True
            except:
                pass
                
            time.sleep(1)
            
        self.logger.warning("Autoslew may not be fully initialized - proceeding with caution")
        return False
        
    def _autoslew_and_check_worker(self):
        """Worker thread for Autoslew startup and connection checking"""
        try:
            # CRITICAL FIX: Do NOT create any driver instances until Autoslew is fully ready
            if hasattr(self, 'telescope') and self.telescope:
                self.telescope.disconnect()
                self.telescope = None
            if hasattr(self, 'rotator') and self.rotator:
                self.rotator.disconnect()
                self.rotator = None
            if hasattr(self, 'cover') and self.cover:
                self.cover.disconnect()
                self.cover = None
                
            # Check if Autoslew is already running
            if self.is_autoslew_running():
                self.logger.info("Autoslew is already running")
                self.update_status("Autoslew", "Running", "green")
                self.autoslew_started = True
                
                # Even if running, wait to ensure it's fully connected
                self._wait_for_autoslew_full_startup()
            else:
                self.logger.info("Starting Autoslew...")
                self.update_status("Autoslew", "Starting...", "orange")
                
                if not os.path.exists(self.autoslew_path):
                    raise FileNotFoundError(f"Autoslew not found at: {self.autoslew_path}")
                    
                # Start Autoslew with specific parameters to minimize conflicts
                subprocess.Popen([
                    self.autoslew_path
                    # Add any Autoslew command line parameters that might help
                ], shell=True, creationflags=subprocess.CREATE_NEW_PROCESS_GROUP)
                
                self.logger.warning("ðŸ”¥ IMPORTANT: Click any Autoslew pop-up windows and allow access!")
                
                # Wait for Autoslew to start
                max_wait = 45  # Increased wait time
                for i in range(max_wait):
                    if i % 5 == 0:  # Log every 5 seconds
                        self.logger.info(f"Waiting for Autoslew startup... {i}/{max_wait} seconds")
                    if self.is_autoslew_running():
                        self.logger.info("Autoslew process started - waiting for full initialization...")
                        self.autoslew_started = True
                        break
                    time.sleep(1)
                else:
                    raise TimeoutError("Autoslew failed to start within 45 seconds")
                    
                # CRITICAL: Wait for full initialization
                if not self._wait_for_autoslew_full_startup():
                    self.logger.error("Autoslew initialization timeout - connections may fail")
                    
                self.update_status("Autoslew", "Running", "green")
            
            # Additional safety delay before attempting Python connections
            self.logger.info("Final safety delay before establishing Python connections...")
            time.sleep(5)
            
            # Now check device connections
            self.logger.info("Establishing Python device connections...")
            self._check_all_connections()
            
        except Exception as e:
            self.logger.error(f"Failed during Autoslew startup: {e}")
        finally:
            # Re-enable UI on main thread
            self.root.after(0, self._finish_autoslew_check)
            
    def _finish_autoslew_check(self):
        """Finish Autoslew check on main thread"""
        self.progress.stop()
        self.autoslew_btn.config(state='normal')
        
        # Enable shutdown button if Autoslew is running
        if self.autoslew_started:
            self.shutdown_btn.config(state='normal')
            
    def _create_driver_with_retry(self, driver_class, config, device_name, max_retries=3):
        """
        CRITICAL FIX: Create drivers with retry and proper error handling
        to avoid DLL conflicts
        """
        for attempt in range(max_retries):
            try:
                self.logger.info(f"Creating {device_name} driver (attempt {attempt + 1}/{max_retries})...")
                
                # Small delay between attempts
                if attempt > 0:
                    time.sleep(2)
                    
                driver = driver_class()
                
                # Test connection
                if driver.connect(config):
                    return driver
                else:
                    driver.disconnect()
                    driver = None
                    if attempt < max_retries - 1:
                        self.logger.warning(f"{device_name} connection failed, retrying...")
                        time.sleep(3)
                    
            except Exception as e:
                self.logger.warning(f"{device_name} driver creation failed (attempt {attempt + 1}): {e}")
                if attempt < max_retries - 1:
                    time.sleep(5)  # Longer delay on exception
                    
        return None
            
    def _check_all_connections(self):
        """Check connections to all devices with improved error handling"""
        
        if not DRIVERS_AVAILABLE:
            self.logger.error("Device drivers not available - cannot check connections")
            return
            
        # Check telescope with retry mechanism
        self.logger.info("Testing telescope connection...")
        try:
            self.telescope = self._create_driver_with_retry(
                AlpacaTelescopeDriver, 
                self.device_configs['telescope'], 
                "telescope"
            )
            
            if self.telescope and self.telescope.is_connected():
                tel_info = self.telescope.get_telescope_info()
                self.logger.info(f"âœ… Telescope connected: {tel_info.get('name', 'Unknown')}")
                self.update_status("Telescope", f"Connected - {tel_info.get('name', 'Unknown')}", "green")
            else:
                raise AlpacaTelescopeError("Connection failed after retries")
        except Exception as e:
            self.logger.warning(f"âŒ Telescope connection failed: {e}")
            self.update_status("Telescope", "Connection Failed", "red")
            if self.telescope:
                self.telescope.disconnect()
                self.telescope = None
                
        # Small delay between device connections
        time.sleep(1)
            
        # Check rotator with retry mechanism
        self.logger.info("Testing rotator connection...")
        try:
            self.rotator = self._create_driver_with_retry(
                AlpacaRotatorDriver,
                self.device_configs['rotator'],
                "rotator"
            )
            
            if self.rotator and self.rotator.is_connected():
                rot_info = self.rotator.get_rotator_info()
                pos = rot_info.get('position_deg', 0)
                self.logger.info(f"âœ… Rotator connected: {rot_info.get('name', 'Unknown')} at {pos:.1f}Â°")
                self.update_status("Rotator", f"Connected - {pos:.1f}Â°", "green")
            else:
                raise AlpacaRotatorError("Connection failed after retries")
        except Exception as e:
            self.logger.warning(f"âŒ Rotator connection failed: {e}")
            self.update_status("Rotator", "Connection Failed", "red")
            if self.rotator:
                self.rotator.disconnect()
                self.rotator = None
                
        # Small delay between device connections
        time.sleep(1)
            
        # Check cover with retry mechanism
        self.logger.info("Testing cover connection...")
        try:
            self.cover = self._create_driver_with_retry(
                AlpacaCoverDriver,
                self.device_configs['cover'],
                "cover"
            )
            
            if self.cover and self.cover.is_connected():
                cover_info = self.cover.get_cover_info()
                state = cover_info.get('cover_state', 'Unknown')
                self.logger.info(f"âœ… Cover connected: {cover_info.get('name', 'Unknown')} - {state}")
                color = "orange" if state == "Open" else "green"
                self.update_status("Cover", f"Connected - {state}", color)
            else:
                raise AlpacaCoverError("Connection failed after retries")
        except Exception as e:
            self.logger.warning(f"âŒ Cover connection failed: {e}")
            self.update_status("Cover", "Connection Failed", "red")
            if self.cover:
                self.cover.disconnect()
                self.cover = None
            
    def confirm_emergency_shutdown(self):
        """Show confirmation dialogs before emergency shutdown"""
        if self.shutdown_in_progress:
            return
            
        # First confirmation
        result1 = messagebox.askyesno(
            "âš ï¸ EMERGENCY SHUTDOWN CONFIRMATION",
            "Are you SURE you want to perform emergency shutdown?\n\n"
            "This will:\n"
            "â€¢ HALT rotator movement\n"  
            "â€¢ CLOSE telescope covers\n"
            "â€¢ PARK telescope\n"
            "â€¢ Turn OFF telescope motors\n\n"
            "Continue?",
            icon='warning'
        )
        
        if not result1:
            return
            
        # Second confirmation (more serious)
        result2 = messagebox.askyesno(
            "ðŸš¨ FINAL CONFIRMATION",
            "LAST CHANCE!\n\n"
            "Are you ABSOLUTELY CERTAIN you want to shutdown the telescope system?\n\n"
            "This action cannot be undone and will stop all telescope operations.\n\n"
            "Only proceed if this is a genuine emergency!",
            icon='error'
        )
        
        if not result2:
            return
            
        # Proceed with shutdown
        self.perform_emergency_shutdown()
        
    def perform_emergency_shutdown(self):
        """Perform the actual emergency shutdown sequence"""
        if self.shutdown_in_progress:
            return
            
        self.shutdown_in_progress = True
        self.shutdown_btn.config(state='disabled', text="SHUTDOWN IN PROGRESS...")
        self.autoslew_btn.config(state='disabled')
        self.progress.start()
        
        # Run shutdown in separate thread
        thread = threading.Thread(target=self._shutdown_worker)
        thread.daemon = True
        thread.start()
        
    def _shutdown_worker(self):
        """Worker thread for emergency shutdown"""
        try:
            self.logger.info("="*50)
            self.logger.info("ðŸš¨ EMERGENCY SHUTDOWN INITIATED ðŸš¨")
            self.logger.info("="*50)
            
            success_count = 0
            total_operations = 0
            
            # 1. Halt rotator if connected and moving
            if self.rotator and self.rotator.is_connected():
                self.logger.info("Step 1: Checking rotator status...")
                try:
                    if self.rotator.is_moving():
                        total_operations += 1
                        self.logger.info("Rotator is moving - halting...")
                        if self.rotator.halt():
                            self.logger.info("âœ… Rotator halted successfully")
                            self.update_status("Rotator", "Halted", "orange")
                            success_count += 1
                        else:
                            self.logger.error("âŒ Rotator halt failed")
                    else:
                        self.logger.info("âœ… Rotator already stationary - no action needed")
                        self.update_status("Rotator", "Stationary", "green")
                except Exception as e:
                    self.logger.error(f"âŒ Rotator status/halt error: {e}")
            else:
                self.logger.info("Step 1: Rotator not connected - skipping halt")
                
            # 2. Close covers if connected and not already closed
            if self.cover:
                self.logger.info("Step 2: Checking cover status...")
                try:
                    cover_state = self.cover.get_cover_state()
                    if cover_state == "Error":
                        self.logger.warning("Cover in error state - skipping close")
                    elif cover_state == "Closed":
                        self.logger.info("âœ… Covers already closed - no action needed")
                        self.update_status("Cover", "Closed", "green")
                    elif cover_state == "Open":
                        total_operations += 1
                        self.logger.info("Covers are open - closing...")
                        if self.cover.close_cover():
                            self.logger.info("âœ… Covers closed successfully")
                            self.update_status("Cover", "Closed", "green")
                            success_count += 1
                        else:
                            self.logger.error("âŒ Cover close failed")
                    else:
                        self.logger.warning(f"Unknown cover state '{cover_state}' - attempting close...")
                        total_operations += 1
                        if self.cover.close_cover():
                            self.logger.info("âœ… Covers closed successfully")
                            self.update_status("Cover", "Closed", "green")
                            success_count += 1
                        else:
                            self.logger.error("âŒ Cover close failed")
                except Exception as e:
                    self.logger.error(f"âŒ Cover status/close error: {e}")
            else:
                self.logger.info("Step 2: Cover not connected - skipping close")
                
            # 3. Park telescope if connected and not already parked
            if self.telescope and self.telescope.is_connected():
                self.logger.info("Step 3: Checking telescope status...")
                
                # Check if already parked
                park_needed = True
                try:
                    if self.telescope.is_parked():
                        self.logger.info("âœ… Telescope already parked - no action needed")
                        park_needed = False
                    elif self.telescope.is_slewing():
                        self.logger.info("Telescope is slewing - aborting slew first...")
                        self.telescope.abort_slew()
                        time.sleep(1)
                        self.logger.info("Slew aborted - proceeding to park...")
                except Exception as e:
                    self.logger.warning(f"Could not check telescope park status: {e} - attempting park anyway")
                
                # Park if needed
                if park_needed:
                    total_operations += 1
                    self.logger.info("Parking telescope...")
                    try:
                        if self.telescope.park(max_wait=60):
                            self.logger.info("âœ… Telescope parked successfully") 
                            success_count += 1
                        else:
                            self.logger.error("âŒ Telescope park failed or timed out")
                    except Exception as e:
                        self.logger.error(f"âŒ Telescope park error: {e}")
                    
                # 4. Turn off motors (always attempt - no way to check motor state)
                total_operations += 1
                self.logger.info("Step 4: Turning off telescope motors...")
                try:
                    if self.telescope.motor_off():
                        self.logger.info("âœ… Telescope motors turned off")
                        self.update_status("Telescope", "Parked & Motors Off", "green")
                        success_count += 1
                    else:
                        self.logger.error("âŒ Motor shutdown failed")
                except Exception as e:
                    self.logger.error(f"âŒ Motor shutdown error: {e}")
            else:
                self.logger.info("Steps 3-4: Telescope not connected - skipping park and motor off")
                
            # Summary
            self.logger.info("="*50)
            if total_operations == 0:
                self.logger.warning("âš ï¸ SHUTDOWN COMPLETE - All systems already in safe state")
            elif success_count == total_operations:
                self.logger.info("âœ… EMERGENCY SHUTDOWN COMPLETED SUCCESSFULLY")
            else:
                self.logger.warning(f"âš ï¸ SHUTDOWN PARTIAL - {success_count}/{total_operations} operations successful")
            self.logger.info("="*50)
            
        except Exception as e:
            self.logger.error(f"ðŸš¨ CRITICAL ERROR during shutdown: {e}")
        finally:
            # Update UI on main thread
            self.root.after(0, self._finish_shutdown)
            
    def _finish_shutdown(self):
        """Finish shutdown on main thread"""
        self.progress.stop()
        self.shutdown_btn.config(text="SHUTDOWN COMPLETE", bg='#6c757d')
        
        # Show completion dialog
        messagebox.showinfo(
            "Shutdown Complete",
            "Emergency shutdown sequence finished.\n\n"
            "Check the activity log above for detailed results.\n\n"
            "You may now close this application.",
            icon='info'
        )
        
    def safe_exit(self):
        """Safely exit the application"""
        if self.shutdown_in_progress:
            if not messagebox.askyesno("Exit During Shutdown?", 
                                     "Shutdown is in progress. Are you sure you want to exit?"):
                return
        
        # CRITICAL FIX: Proper cleanup to avoid DLL conflicts on exit
        self.logger.info("Cleaning up connections...")
        try:
            if self.telescope:
                self.telescope.disconnect()
                self.telescope = None
            if self.rotator:
                self.rotator.disconnect()
                self.rotator = None
            if self.cover:
                self.cover.disconnect()
                self.cover = None
        except Exception as e:
            self.logger.warning(f"Cleanup warning: {e}")
                
        self.root.quit()
        self.root.destroy()
        
    def run(self):
        """Start the GUI application"""
        try:
            self.root.mainloop()
        except KeyboardInterrupt:
            self.logger.info("Application interrupted")
        finally:
            # Cleanup on exit
            try:
                if hasattr(self, 'telescope') and self.telescope:
                    self.telescope.disconnect()
                if hasattr(self, 'rotator') and self.rotator:
                    self.rotator.disconnect()  
                if hasattr(self, 'cover') and self.cover:
                    self.cover.disconnect()
            except:
                pass


class LogHandler(logging.Handler):
    """Custom log handler to display logs in the GUI"""
    
    def __init__(self, gui):
        super().__init__()
        self.gui = gui
        
    def emit(self, record):
        """Emit a log record to the GUI"""
        try:
            msg = self.format(record)
            # Schedule GUI update on main thread
            self.gui.root.after(0, lambda: self._update_log_display(msg))
        except Exception:
            pass
            
    def _update_log_display(self, message):
        """Update log display widget"""
        try:
            self.gui.log_display.config(state='normal')
            self.gui.log_display.insert(tk.END, message + '\n')
            self.gui.log_display.see(tk.END)
            self.gui.log_display.config(state='disabled')
        except Exception:
            pass


def main():
    """Main entry point"""
    if not DRIVERS_AVAILABLE:
        print("ERROR: Required device drivers not found!")
        print("Make sure alpaca_telescope.py, alpaca_rotator.py, and alpaca_cover.py are in the same directory.")
        input("Press Enter to exit...")
        return 1
        
            app = EmergencyShutdownGUI()
        app.run()
        return 0
    except Exception as e:
        print(f"Application error: {e}")
        input("Press Enter to exit...")
        return 1


if __name__ == "__main__":
    sys.exit(main())
