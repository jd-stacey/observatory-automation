Perfect — thanks for the observatory + session files. Given you’re Alt/Az-only on the ASA DDM500 and running Astropy 6.0.1, we can let Astropy handle all the sky/time bits (precession, nutation, topo/apparent) and keep our rotator logic thin:

We feed your J2000 ICRS target (what you already use) into Astropy and transform to AltAz at Time.now() on every tracker tick. Astropy handles the “J2000 vs of-date” internally in the FK5/ICRS→CIRS→AltAz pipeline, so you don’t need to pre-convert the target to JNow yourself.

We continuously de-rotate using parallactic angle (AltAz.parallactic_angle()), keeping the detector PA locked frame-to-frame.

We only do coarse operations (e.g., 180° setpoint flips for wrap avoidance) between frames — I’ve added two tiny hooks in ImagingSession so this is guaranteed.

Below are surgical changes you can paste in. They preserve your structure and configs and use your existing theta_offset from platesolving as calibration feedback (not a discrete MoveAbsolute), so stars stay on (nearly) the same pixels.

1) alpaca_rotator.py — add a small Astropy-based field tracker

Add these imports near the top:

import threading
import numpy as np
from dataclasses import dataclass
from astropy.coordinates import SkyCoord, AltAz, EarthLocation
from astropy.time import Time, TimeDelta
import astropy.units as u


Add a tiny tracker (inside this file, below your class definitions is fine):

@dataclass
class _Calib:
    zero_offset_deg: float = 0.0     # mech angle when sky PA = 0° (north-up)
    sign:      int   = +1            # +1 or -1 (we’ll test)
    sky_pa_set_deg: float | None = None  # reference PA (Alt/Az), fixed PA if needed

@dataclass
class _Limits:
    min_deg: float
    max_deg: float
    margin_deg: float = 3.0

@dataclass
class _Cfg:
    lat_deg: float
    lon_deg: float
    elev_m:  float
    hz: float = 10.0
    move_thresh_deg: float = 0.05
    lookahead_min: float   = 20.0    # plan wraps ahead (min)

class _FieldTracker:
    """
    Continuous field de-rotation for Alt/Az using Astropy’s parallactic_angle().
    Keeps stars on the same pixels with tiny thresholded nudges.
    """
    def __init__(self, rot_drv: "AlpacaRotatorDriver", cfg: _Cfg, cal: _Calib, lim: _Limits):
        self.rot = rot_drv
        self.cfg, self.cal, self.lim = cfg, cal, lim
        self.loc = EarthLocation(self.cfg.lon_deg*u.deg, self.cfg.lat_deg*u.deg, self.cfg.elev_m*u.m)
        self._target = None            # (ra_deg, dec_deg) in ICRS/J2000 — Astropy handles of-date internally
        self._pa_ref = None            # reference PA (locked Alt/Az image orientation)
        self._stop = threading.Event()
        self._th = None
        self._in_exp = False
        self._last_pa_cmd = None

    def set_target(self, ra_hours: float, dec_deg: float, pa_ref_now: float | None):
        self._target = (ra_hours * 15.0, float(dec_deg))  # store RA in deg
        if pa_ref_now is not None:
            self._pa_ref = float(pa_ref_now)

    def notify_exposure_start(self): self._in_exp = True
    def notify_exposure_end(self):   self._in_exp = False

    def apply_wcs_pa_feedback(self, measured_pa_deg: float):
        """Use platesolved image PA (east-of-north) as zero-offset feedback (shortest signed delta)."""
        if self._last_pa_cmd is None:
            return
        delta = (measured_pa_deg - self._last_pa_cmd + 540) % 360 - 180
        self.cal.zero_offset_deg -= self.cal.sign * delta
        logger.info(f"[rot-cal] zero_offset -> {self.cal.zero_offset_deg:.3f}° (delta {delta:+.3f}°)")

    def start(self):
        if self._th and self._th.is_alive(): return
        self._stop.clear()
        self._th = threading.Thread(target=self._run, daemon=True)
        self._th.start()
        logger.info("Rotator field-tracking started")

    def stop(self):
        self._stop.set()
        if self._th: self._th.join(timeout=3)
        logger.info("Rotator field-tracking stopped")

    def _desired_sky_pa(self, t: Time) -> float:
        ra_deg, dec_deg = self._target
        sc = SkyCoord(ra=ra_deg*u.deg, dec=dec_deg*u.deg, frame='icrs')  # J2000 ICRS in
        # Astropy transforms to topocentric AltAz at t, accounting for of-date effects.
        q = sc.transform_to(AltAz(obstime=t, location=self.loc)).parallactic_angle().to(u.deg).value
        pa_ref = self._pa_ref if self._pa_ref is not None else (self.cal.sky_pa_set_deg or 0.0)
        return float(pa_ref - q)  # keep detector fixed relative to sky; (east-of-north)

    def _sky_to_mech(self, pa_sky_deg: float) -> float:
        return self.cal.sign * (pa_sky_deg + self.cal.zero_offset_deg)

    def _wrap_into_limits(self, theta: float) -> float:
        lo = self.lim.min_deg + self.lim.margin_deg
        hi = self.lim.max_deg - self.lim.margin_deg
        span = hi - lo
        return lo + (theta - lo) % span

    def _wrap_looms(self, t0: Time) -> bool:
        if not self._target: return False
        ra_deg, dec_deg = self._target
        sc = SkyCoord(ra=ra_deg*u.deg, dec=dec_deg*u.deg, frame='icrs')
        times = t0 + TimeDelta(np.linspace(0, self.cfg.lookahead_min*60, 30), format='sec')
        q = sc.transform_to(AltAz(obstime=times, location=self.loc)).parallactic_angle().to(u.deg).value
        pa_ref = self._pa_ref if self._pa_ref is not None else (self.cal.sky_pa_set_deg or 0.0)
        pa = pa_ref - q
        th = self._wrap_into_limits(self._sky_to_mech(pa))
        return (th < self.lim.min_deg + 2*self.lim.margin_deg).any() or \
               (th > self.lim.max_deg - 2*self.lim.margin_deg).any()

    def _flip_setpoint_180(self):
        base = self.cal.sky_pa_set_deg if self.cal.sky_pa_set_deg is not None else (self._pa_ref or 0.0)
        self.cal.sky_pa_set_deg = base + 180.0
        logger.info(f"[rot-wrap] flipped PA setpoint by 180° -> {self.cal.sky_pa_set_deg:.2f}°")

    def _run(self):
        dt = 1.0/max(1.0, self.cfg.hz)
        while not self._stop.is_set():
            try:
                if not self.rot.is_connected() or not self._target:
                    time.sleep(dt); continue
                t = Time.now()
                pa_sky = self._desired_sky_pa(t)
                self._last_pa_cmd = pa_sky
                theta_des = self._wrap_into_limits(self._sky_to_mech(pa_sky))
                theta_now = float(self.rot.get_position())
                err = (theta_des - theta_now + 540) % 360 - 180
                if abs(err) > self.cfg.move_thresh_deg:
                    self.rot.rotator.MoveAbsolute(theta_des)
                if not self._in_exp and self._wrap_looms(t):
                    self._flip_setpoint_180()
            except Exception as e:
                logger.warning(f"rotator tracking loop: {e}")
            time.sleep(dt)


Extend your AlpacaRotatorDriver with tracker state (in __init__):

        self._tracker = None
        self._cal = _Calib()   # zero/sign are testable; sign unknown → we’ll flip if needed


Add these public methods to AlpacaRotatorDriver (near the end of the class):

    # ---------- Field tracking API ----------
    def start_field_tracking(self, ra_hours: float, dec_deg: float, observatory_cfg: dict,
                             sky_pa_reference_deg: float | None = None,
                             update_hz: float = 10.0, move_thresh_deg: float = 0.05):
        if not self.is_connected():
            logger.warning("start_field_tracking: rotator not connected")
            return False

        lim = _Limits(self.min_limit, self.max_limit,
                      margin_deg=float(self.config.get('limits', {}).get('emergency_margin_deg', 1.0)))

        # observatory.yaml keys:
        lat = float(observatory_cfg.get('latitude'))
        lon = float(observatory_cfg.get('longitude'))
        elev = float(observatory_cfg.get('altitude', 0.0))

        cfg = _Cfg(lat_deg=lat, lon_deg=lon, elev_m=elev, hz=update_hz, move_thresh_deg=move_thresh_deg)
        self._tracker = _FieldTracker(self, cfg, self._cal, lim)
        self._tracker.set_target(ra_hours, dec_deg, pa_ref_now=sky_pa_reference_deg)
        self._tracker.start()
        return True

    def stop_field_tracking(self):
        if self._tracker:
            self._tracker.stop()
            self._tracker = None
            return True
        return False

    def tracking_set_target(self, ra_hours: float, dec_deg: float, pa_ref_now: float | None = None):
        if self._tracker:
            self._tracker.set_target(ra_hours, dec_deg, pa_ref_now)

    def tracking_notify_exposure_start(self):
        if self._tracker:
            self._tracker.notify_exposure_start()

    def tracking_notify_exposure_end(self):
        if self._tracker:
            self._tracker.notify_exposure_end()

    def tracking_apply_wcs_pa_feedback(self, measured_pa_deg: float):
        if self._tracker:
            self._tracker.apply_wcs_pa_feedback(measured_pa_deg)


J2000 vs JNow note: you keep feeding J2000 ICRS (TargetInfo.ra_j2000_hours/dec) to the tracker; Astropy converts to of-date AltAz each cycle. Nothing else to do.

2) corrector.py — use theta_offset as calibration feedback (no discrete jump)

Inside apply_single_correction(...), replace the rotation block:

rotation_correction_needed = self.rotator_driver and abs(rot_offset_deg) >= min_rotation

if rotation_correction_needed:
    # Prefer calibration feedback to avoid image jumps
    try:
        # If your solver’s theta means “rotate image by +θ to fix”, then treat it as a measured PA delta.
        # Pass the *measured image PA* = (commanded + theta_offset). Using +θ here makes the
        # zero-offset converge. If it goes the wrong way in testing, flip the sign once.
        self.rotator_driver.tracking_apply_wcs_pa_feedback(measured_pa_deg = rot_offset_deg)
        rotation_success = True
        logger.info(f"Fed rotator θ feedback (Δ={rot_offset_deg:+.2f}°) into zero-offset calibration")
    except AttributeError:
        logger.info(f"Applying rotation correction (legacy discrete move): {rot_offset_deg:+.2f}°")
        rotation_success = self.rotator_driver.apply_rotation_correction(rot_offset_deg)


(Leave the rest unchanged.)
We’ll confirm the sign empirically during first light; if it diverges, flip the sign in that one call.

3) main.py — start/stop field tracking around the session

Right after you initialize PlatesolveCorrector and before Starting imaging session..., add:

            # Start continuous field de-rotation (Alt/Az) if rotator present
            if rotator_driver:
                try:
                    observatory_cfg = config_loader.get_config('observatory')
                    # Start with no explicit reference PA: the first platesolve will feed θ as calibration
                    rotator_driver.start_field_tracking(
                        ra_hours=target_info.ra_j2000_hours,
                        dec_deg=target_info.dec_j2000_deg,
                        observatory_cfg=observatory_cfg,
                        sky_pa_reference_deg=None,
                        update_hz=10.0,
                        move_thresh_deg=0.05
                    )
                except Exception as e:
                    logger.warning(f"Failed to start rotator field-tracking: {e}")


And in finally: add a safe stop (before disconnecting the rotator/device stack):

            try:
                if rotator_driver:
                    rotator_driver.stop_field_tracking()
            except Exception:
                pass

4) session.py — ensure between-frames only

Inside capture_single_exposure() wrap the camera call with rotator hooks:

            # BEFORE starting the exposure
            try:
                if self.corrector and hasattr(self.corrector, 'rotator_driver') and self.corrector.rotator_driver:
                    self.corrector.rotator_driver.tracking_notify_exposure_start()
            except Exception:
                pass

            image_array = self.main_camera.capture_image(
                exposure_time=exposure_time,
                binning=binning, 
                gain=gain, 
                light=True
            )

            # AFTER exposure completes
            try:
                if self.corrector and hasattr(self.corrector, 'rotator_driver') and self.corrector.rotator_driver:
                    self.corrector.rotator_driver.tracking_notify_exposure_end()
            except Exception:
                pass


This guarantees any 180° wrap flip or coarse setpoint shift only happens after a frame ends, never mid-exposure, and keeps inter-frame latency minimal.

Defaults & things we’ll test once on-sky

Sign (_Calib.sign): set +1 initially; if measured PA feedback diverges, flip to -1.

Zero offset: converges automatically from platesolve theta_offset feedback; you can persist it to config later if you want “instant lock” next time.

Rates: update_hz=10 and move_thresh_deg=0.05 give sub-pixel drift for 1–2 s exposures without chatter.

Limits: taken from your devices.yaml (94–320°) with margin = emergency_margin_deg (1°) by default.

TL;DR on J2000 vs JNow (your explicit ask)

You keep sending ICRS J2000 to both mount and tracker.

The mount tracks Alt/Az; its model handles of-date pointing.

The rotator tracker computes parallactic angle by transforming that ICRS position to AltAz at the current time & site; Astropy handles precession/nutation/refraction in the transform. So you’re “accounting for JNow” automatically where it matters (field rotation), without manual conversion.
