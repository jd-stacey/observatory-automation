#!/usr/bin/env python3
"""
Emergency Telescope Shutdown Tool
Safely shuts down telescope system after TCU restart or other emergencies.
FIXED: Handles CLServo.dll missing error and provides alternative startup methods
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import subprocess
import time
import threading
import logging
import sys
from pathlib import Path
import psutil
import os
import requests
import json
import shutil
from typing import Optional, Dict, Any

# Import your existing drivers (assuming they're in the same directory or Python path)
try:
    from alpaca_telescope import AlpacaTelescopeDriver, AlpacaTelescopeError
    from alpaca_rotator import AlpacaRotatorDriver, AlpacaRotatorError  
    from alpaca_cover import AlpacaCoverDriver, AlpacaCoverError
    DRIVERS_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Could not import drivers: {e}")
    DRIVERS_AVAILABLE = False

class EmergencyShutdownGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Emergency Telescope Shutdown")
        self.root.geometry("700x850")  # Slightly taller for error handling
        self.root.configure(bg='#f0f0f0')
        
        # Make window stay on top initially
        self.root.attributes('-topmost', True)
        
        # Device configurations (from your devices.yaml)
        self.device_configs = {
            'telescope': {
                'address': '127.0.0.1:11111',
                'device_number': 0,
                'settle_time': 2.0
            },
            'rotator': {
                'address': '127.0.0.1:11112', 
                'device_number': 0,
                'settle_time': 0.1,
                'mechanical_limits': {'min_deg': 94.0, 'max_deg': 320.0}
            },
            'cover': {
                'address': '127.0.0.1:11112',
                'device_number': 0,
                'operation_timeout': 30.0,
                'settle_time': 15.0
            }
        }
        
        self.autoslew_path = r"C:\Program Files (x86)\Autoslew\Autoslew.exe"
        self.autoslew_dir = r"C:\Program Files (x86)\Autoslew"
        
        # Device drivers - only created during shutdown
        self.telescope = None
        self.rotator = None  
        self.cover = None
        
        # Device status via HTTP only
        self.device_status = {
            'telescope': {'connected': False, 'info': {}},
            'rotator': {'connected': False, 'info': {}},
            'cover': {'connected': False, 'info': {}}
        }
        
        # GUI state
        self.shutdown_in_progress = False
        self.autoslew_started = False
        self.manual_mode = False  # For when automatic startup fails
        
        self.setup_logging()
        self.create_widgets()
        self.center_window()
        
        # Check for common issues on startup
        self.check_autoslew_installation()
        
    def setup_logging(self):
        """Setup logging to display in GUI"""
        self.log_handler = LogHandler(self)
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[self.log_handler]
        )
        self.logger = logging.getLogger(__name__)
        
    def create_widgets(self):
        """Create the GUI widgets"""
        
        # Title
        title_frame = tk.Frame(self.root, bg='#d32f2f', height=60)
        title_frame.pack(fill='x', padx=5, pady=5)
        title_frame.pack_propagate(False)
        
        title_label = tk.Label(
            title_frame, 
            text="‚ö†Ô∏è EMERGENCY TELESCOPE SHUTDOWN ‚ö†Ô∏è", 
            font=('Arial', 14, 'bold'),
            fg='white', 
            bg='#d32f2f'
        )
        title_label.pack(expand=True)
        
        # Warning text
        warning_frame = tk.Frame(self.root, bg='#fff3cd', relief='solid', bd=1)
        warning_frame.pack(fill='x', padx=10, pady=5)
        
        warning_text = tk.Text(
            warning_frame, 
            height=4, 
            bg='#fff3cd', 
            fg='#856404',
            font=('Arial', 10),
            relief='flat',
            wrap='word'
        )
        warning_text.pack(fill='x', padx=10, pady=10)
        warning_text.insert('1.0', 
            "‚ö†Ô∏è  This tool performs emergency shutdown of telescope systems.\n"
            "‚ö†Ô∏è  Use only after TCU restart or system failure.\n"
            "‚ö†Ô∏è  This will STOP rotator, CLOSE covers, PARK telescope, and turn OFF motors.\n"
            "‚ö†Ô∏è  Multiple confirmations required - do not use during normal operations!")
        warning_text.config(state='disabled')
        
        # Buttons frame
        button_frame = tk.Frame(self.root, bg='#f0f0f0')
        button_frame.pack(fill='x', padx=10, pady=10)
        
        # Start Autoslew button
        self.autoslew_btn = tk.Button(
            button_frame,
            text="1. Start Autoslew & Check Connections",
            command=self.start_autoslew_and_check,
            bg='#4CAF50',
            fg='white',
            font=('Arial', 11, 'bold'),
            height=2
        )
        self.autoslew_btn.pack(fill='x', pady=5)
        
        # Manual check button (initially hidden)
        self.manual_btn = tk.Button(
            button_frame,
            text="1b. Manual Check (if Autoslew won't start)",
            command=self.manual_check_connections,
            bg='#FF9800',
            fg='white',
            font=('Arial', 10, 'bold'),
            height=2
        )
        # Don't pack initially
        
        # Emergency shutdown button (initially disabled)
        self.shutdown_btn = tk.Button(
            button_frame,
            text="2. EMERGENCY SHUTDOWN",
            command=self.confirm_emergency_shutdown,
            bg='#d32f2f',
            fg='white', 
            font=('Arial', 11, 'bold'),
            height=2,
            state='disabled'
        )
        self.shutdown_btn.pack(fill='x', pady=5)
        
        # Fix DLL button (initially hidden)
        self.fix_dll_btn = tk.Button(
            button_frame,
            text="üîß Try to Fix CLServo.dll Issue",
            command=self.try_fix_dll_issue,
            bg='#9C27B0',
            fg='white',
            font=('Arial', 10)
        )
        # Don't pack initially
        
        # Exit button
        self.exit_btn = tk.Button(
            button_frame,
            text="Exit",
            command=self.safe_exit,
            bg='#6c757d',
            fg='white',
            font=('Arial', 10)
        )
        self.exit_btn.pack(fill='x', pady=5)
        
        # Status frame
        status_frame = tk.LabelFrame(self.root, text="System Status", bg='#f0f0f0', font=('Arial', 10, 'bold'))
        status_frame.pack(fill='x', padx=10, pady=5)
        
        # Status labels
        self.status_labels = {}
        for device in ['Autoslew', 'Telescope', 'Rotator', 'Cover']:
            frame = tk.Frame(status_frame, bg='#f0f0f0')
            frame.pack(fill='x', padx=5, pady=2)
            
            label = tk.Label(frame, text=f"{device}:", bg='#f0f0f0', font=('Arial', 9))
            label.pack(side='left')
            
            status = tk.Label(frame, text="Not Connected", bg='#f0f0f0', fg='red', font=('Arial', 9, 'bold'))
            status.pack(side='right')
            
            self.status_labels[device] = status
            
        # Log display
        log_frame = tk.LabelFrame(self.root, text="Activity Log", bg='#f0f0f0', font=('Arial', 10, 'bold'))
        log_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.log_display = scrolledtext.ScrolledText(
            log_frame, 
            height=12, 
            bg='black', 
            fg='lime',
            font=('Consolas', 9),
            state='disabled'
        )
        self.log_display.pack(fill='both', expand=True, padx=5, pady=5)
        
        # Progress bar
        self.progress = ttk.Progressbar(self.root, mode='indeterminate')
        self.progress.pack(fill='x', padx=10, pady=5)
        
        self.logger.info("Emergency Shutdown Tool initialized")
        
    def check_autoslew_installation(self):
        """Check for common Autoslew installation issues"""
        if not os.path.exists(self.autoslew_path):
            self.logger.error(f"‚ùå Autoslew not found at: {self.autoslew_path}")
            self.logger.error("   Please verify Autoslew installation path")
            return
            
        # Check for CLServo.dll
        clservo_path = os.path.join(self.autoslew_dir, "CLServo.dll")
        if not os.path.exists(clservo_path):
            self.logger.warning("‚ö†Ô∏è CLServo.dll not found - this may cause Autoslew startup errors")
            self.fix_dll_btn.pack(fill='x', pady=2)
            self.logger.info("   Click 'üîß Try to Fix CLServo.dll Issue' button below if Autoslew fails to start")
        else:
            self.logger.info("‚úÖ CLServo.dll found")
            
        self.logger.info("Click 'Start Autoslew & Check Connections' to begin")
        
    def try_fix_dll_issue(self):
        """Attempt to fix the CLServo.dll issue"""
        self.logger.info("üîß Attempting to fix CLServo.dll issue...")
        
        # Strategy 1: Look for CLServo.dll in common locations
        possible_locations = [
            r"C:\Program Files\Common Files\ASCOM\CLServo",
            r"C:\Program Files (x86)\Common Files\ASCOM\CLServo", 
            r"C:\Windows\System32",
            r"C:\Windows\SysWOW64",
            os.path.join(self.autoslew_dir, "Backup"),
            os.path.join(self.autoslew_dir, "Archive")
        ]
        
        found_dll = None
        for location in possible_locations:
            dll_path = os.path.join(location, "CLServo.dll")
            if os.path.exists(dll_path):
                found_dll = dll_path
                self.logger.info(f"‚úÖ Found CLServo.dll at: {location}")
                break
                
        if found_dll:
            try:
                target_path = os.path.join(self.autoslew_dir, "CLServo.dll")
                shutil.copy2(found_dll, target_path)
                self.logger.info(f"‚úÖ Copied CLServo.dll to Autoslew directory")
                self.fix_dll_btn.pack_forget()  # Hide the button
                return True
            except Exception as e:
                self.logger.error(f"‚ùå Failed to copy CLServo.dll: {e}")
                
        # Strategy 2: Suggest manual solutions
        self.logger.warning("‚ùå Could not automatically fix CLServo.dll issue")
        self.logger.info("üí° MANUAL SOLUTIONS:")
        self.logger.info("   1. Try running Autoslew as Administrator")
        self.logger.info("   2. Reinstall Autoslew")  
        self.logger.info("   3. Contact Autoslew support about missing CLServo.dll")
        self.logger.info("   4. Use 'Manual Check' button if Autoslew is already running")
        
        # Show manual check button
        self.manual_btn.pack(fill='x', pady=2)
        
        return False
        
    def center_window(self):
        """Center window on screen"""
        self.root.update_idletasks()
        x = (self.root.winfo_screenwidth() // 2) - (self.root.winfo_width() // 2)
        y = (self.root.winfo_screenheight() // 2) - (self.root.winfo_height() // 2)
        self.root.geometry(f"+{x}+{y}")
        
    def update_status(self, device: str, status: str, color: str = 'red'):
        """Update device status display"""
        if device in self.status_labels:
            self.status_labels[device].config(text=status, fg=color)
            
    def is_autoslew_running(self) -> bool:
        """Check if Autoslew is already running"""
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                if 'autoslew' in proc.info['name'].lower():
                    return True
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        return False
        
    def start_autoslew_and_check(self):
        """Start Autoslew and check device connections"""
        if self.shutdown_in_progress:
            return
            
        # Disable button and start progress
        self.autoslew_btn.config(state='disabled')
        self.progress.start()
        
        # Run in separate thread
        thread = threading.Thread(target=self._autoslew_and_check_worker)
        thread.daemon = True
        thread.start()
        
    def manual_check_connections(self):
        """Manual connection check when Autoslew startup fails"""
        if self.shutdown_in_progress:
            return
            
        self.logger.info("üîç Starting manual connection check...")
        self.logger.info("   This assumes Autoslew is already running or will be started manually")
        
        self.manual_btn.config(state='disabled')
        self.progress.start()
        
        # Run in separate thread
        thread = threading.Thread(target=self._manual_check_worker)
        thread.daemon = True
        thread.start()
        
    def _manual_check_worker(self):
        """Worker thread for manual connection checking"""
        try:
            self.manual_mode = True
            
            if self.is_autoslew_running():
                self.logger.info("‚úÖ Autoslew process detected")
                self.update_status("Autoslew", "Running (Manual)", "green")
                self.autoslew_started = True
            else:
                self.logger.warning("‚ö†Ô∏è Autoslew not running - please start it manually")
                self.update_status("Autoslew", "Please Start Manually", "orange")
                
            # Wait a bit for manual startup
            self.logger.info("‚è≥ Waiting 30 seconds for manual Autoslew startup...")
            for i in range(30):
                if self.is_autoslew_running() and not self.autoslew_started:
                    self.logger.info("‚úÖ Autoslew detected!")
                    self.update_status("Autoslew", "Running (Manual)", "green")
                    self.autoslew_started = True
                    break
                time.sleep(1)
                
            # Check connections regardless
            self.logger.info("üîç Checking device connections...")
            self._check_all_connections_http_only()
            
        except Exception as e:
            self.logger.error(f"‚ùå Manual check failed: {e}")
        finally:
            self.root.after(0, self._finish_manual_check)
            
    def _finish_manual_check(self):
        """Finish manual check on main thread"""
        self.progress.stop()
        self.manual_btn.config(state='normal')
        
        # Enable shutdown if we detected devices
        connected_devices = sum(1 for dev in self.device_status.values() if dev['connected'])
        if connected_devices > 0:
            self.shutdown_btn.config(state='normal')
            self.logger.info(f"‚úÖ {connected_devices} devices detected - shutdown enabled")
        else:
            self.logger.warning("‚ö†Ô∏è No devices detected - check that Autoslew is running and connected")
        
    def _http_get_device_info(self, address: str, device_type: str, device_number: int, property_name: str):
        """Use ONLY HTTP requests - no driver instantiation"""
        try:
            url = f"http://{address}/api/v1/{device_type}/{device_number}/{property_name}"
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                data = response.json()
                return data.get('Value'), None
            else:
                return None, f"HTTP {response.status_code}"
        except Exception as e:
            return None, str(e)
            
    def _http_check_device_connected(self, address: str, device_type: str, device_number: int):
        """Check if device is connected via HTTP only"""
        try:
            url = f"http://{address}/api/v1/{device_type}/{device_number}/connected"
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                data = response.json()
                return data.get('Value', False)
            return False
        except:
            return False
            
    def _check_alpaca_service_ready(self, address, device_type, device_number):
        """Check if ALPACA service responds"""
        try:
            connected = self._http_check_device_connected(address, device_type, device_number)
            return connected is not None  # Service responded (even if device not connected)
        except:
            return False
        
    def _autoslew_and_check_worker(self):
        """Worker thread for Autoslew startup with better error handling"""
        try:
            self.logger.info("üöÄ Starting Autoslew launch sequence...")
            
            # Check if already running first
            if self.is_autoslew_running():
                self.logger.info("‚úÖ Autoslew is already running")
                self.update_status("Autoslew", "Running", "green")
                self.autoslew_started = True
                
                # Wait for services to be ready
                self.logger.info("‚è≥ Waiting for ALPACA services...")
                time.sleep(10)
            else:
                self.logger.info("üîß Starting Autoslew...")
                self.update_status("Autoslew", "Starting...", "orange")
                
                if not os.path.exists(self.autoslew_path):
                    raise FileNotFoundError(f"Autoslew not found at: {self.autoslew_path}")
                
                try:
                    # Try starting Autoslew with different methods
                    self.logger.info("   Attempt 1: Normal startup...")
                    proc = subprocess.Popen([self.autoslew_path], 
                                          cwd=self.autoslew_dir,
                                          shell=False)
                    
                    # Wait briefly to see if it starts without error
                    time.sleep(5)
                    
                    if proc.poll() is not None:
                        # Process exited - likely the CLServo.dll error
                        self.logger.warning("‚ö†Ô∏è Autoslew exited immediately - likely CLServo.dll error")
                        raise subprocess.SubprocessError("Autoslew failed to start")
                        
                    self.logger.info("üî• Allow Autoslew through any security prompts!")
                    
                except Exception as startup_error:
                    self.logger.error(f"‚ùå Autoslew startup failed: {startup_error}")
                    self.logger.info("üí° Suggestions:")
                    self.logger.info("   1. Check for CLServo.dll error dialog")
                    self.logger.info("   2. Try running as Administrator")
                    self.logger.info("   3. Start Autoslew manually, then use 'Manual Check'")
                    self.root.after(0, lambda: self.manual_btn.pack(fill='x', pady=2))
                    return
                
                # Wait for process to start
                max_wait = 60
                for i in range(max_wait):
                    if i % 10 == 0 and i > 0:
                        self.logger.info(f"‚è≥ Waiting for Autoslew... {i}/{max_wait} seconds")
                    if self.is_autoslew_running():
                        self.logger.info("‚úÖ Autoslew process started")
                        self.autoslew_started = True
                        break
                    time.sleep(1)
                else:
                    raise TimeoutError("Autoslew process not detected within 60 seconds")
                    
                self.update_status("Autoslew", "Running", "green")
            
            # Wait for full initialization
            self.logger.info("‚è≥ Waiting for Autoslew full initialization...")
            max_service_wait = 180  # 3 minutes for problem cases
            service_ready = False
            
            for attempt in range(0, max_service_wait, 15):
                if attempt > 0:
                    self.logger.info(f"üîç Testing ALPACA services... ({attempt}/{max_service_wait}s)")
                
                telescope_ready = self._check_alpaca_service_ready("127.0.0.1:11111", "telescope", 0)
                rotator_ready = self._check_alpaca_service_ready("127.0.0.1:11112", "rotator", 0)  
                cover_ready = self._check_alpaca_service_ready("127.0.0.1:11112", "covercalibrator", 0)
                
                if telescope_ready or rotator_ready or cover_ready:
                    self.logger.info("‚úÖ At least one ALPACA service responding")
                    service_ready = True
                    break
                    
                if attempt < max_service_wait - 15:
                    time.sleep(15)
            
            if not service_ready:
                self.logger.warning("‚ö†Ô∏è ALPACA services not responding")
                self.logger.info("üí° Try 'Manual Check' if Autoslew appears to be running")
                self.root.after(0, lambda: self.manual_btn.pack(fill='x', pady=2))
            
            # Check device connections
            self.logger.info("üîç Checking device status...")
            self._check_all_connections_http_only()
            
        except Exception as e:
            self.logger.error(f"‚ùå Autoslew startup failed: {e}")
            self.logger.info("üí° Try using 'Manual Check' button if Autoslew is running")
            self.root.after(0, lambda: self.manual_btn.pack(fill='x', pady=2))
        finally:
            self.root.after(0, self._finish_autoslew_check)
            
    def _finish_autoslew_check(self):
        """Finish Autoslew check on main thread"""
        self.progress.stop()
        self.autoslew_btn.config(state='normal')
        
        # Enable shutdown button based on what we found
        if self.autoslew_started or any(dev['connected'] for dev in self.device_status.values()):
            self.shutdown_btn.config(state='normal')
            
    def _check_all_connections_http_only(self):
        """Check connections using ONLY HTTP requests"""
        
        # Check telescope
        self.logger.info("üî≠ Checking telescope...")
        try:
            connected = self._http_check_device_connected("127.0.0.1:11111", "telescope", 0)
            if connected:
                name, _ = self._http_get_device_info("127.0.0.1:11111", "telescope", 0, "name")
                description, _ = self._http_get_device_info("127.0.0.1:11111", "telescope", 0, "description")
                
                tel_name = name or description or "Unknown Telescope"
                self.logger.info(f"‚úÖ Telescope connected: {tel_name}")
                self.update_status("Telescope", f"Connected - {tel_name}", "green")
                self.device_status['telescope']['connected'] = True
                self.device_status['telescope']['info'] = {'name': tel_name}
            else:
                self.logger.warning("‚ùå Telescope not connected")
                self.update_status("Telescope", "Not Connected", "red")
                
        except Exception as e:
            self.logger.warning(f"‚ùå Telescope check failed: {e}")
            self.update_status("Telescope", "Check Failed", "red")
            
        # Check rotator
        self.logger.info("üîÑ Checking rotator...")
        try:
            connected = self._http_check_device_connected("127.0.0.1:11112", "rotator", 0)
            if connected:
                position, _ = self._http_get_device_info("127.0.0.1:11112", "rotator", 0, "position")
                name, _ = self._http_get_device_info("127.0.0.1:11112", "rotator", 0, "name")
                
                pos_deg = position if position is not None else 0.0
                rot_name = name or "Unknown Rotator"
                self.logger.info(f"‚úÖ Rotator connected: {rot_name} at {pos_deg:.1f}¬∞")
                self.update_status("Rotator", f"Connected - {pos_deg:.1f}¬∞", "green")
                self.device_status['rotator']['connected'] = True
                self.device_status['rotator']['info'] = {'name': rot_name, 'position_deg': pos_deg}
            else:
                self.logger.warning("‚ùå Rotator not connected")
                self.update_status("Rotator", "Not Connected", "red")
                
        except Exception as e:
            self.logger.warning(f"‚ùå Rotator check failed: {e}")
            self.update_status("Rotator", "Check Failed", "red")
            
        # Check cover
        self.logger.info("üõ°Ô∏è Checking cover...")
        try:
            connected = self._http_check_device_connected("127.0.0.1:11112", "covercalibrator", 0)
            if connected:
                cover_state, _ = self._http_get_device_info("127.0.0.1:11112", "covercalibrator", 0, "coverstate")
                name, _ = self._http_get_device_info("127.0.0.1:11112", "covercalibrator", 0, "name")
                
                state_map = {0: "Unknown", 1: "Closed", 2: "Moving", 3: "Open", 4: "Error"}
                state_name = state_map.get(cover_state, f"State{cover_state}")
                
                cover_name = name or "Unknown Cover"
                self.logger.info(f"‚úÖ Cover connected: {cover_name} - {state_name}")
                
                color = "green" if state_name == "Closed" else "orange" if state_name == "Open" else "red"
                self.update_status("Cover", f"Connected - {state_name}", color)
                self.device_status['cover']['connected'] = True
                self.device_status['cover']['info'] = {'name': cover_name, 'cover_state': state_name}
            else:
                self.logger.warning("‚ùå Cover not connected")
                self.update_status("Cover", "Not Connected", "red")
                
        except Exception as e:
            self.logger.warning(f"‚ùå Cover check failed: {e}")
            self.update_status("Cover", "Check Failed", "red")
        
        # Summary
        connected_count = sum(1 for dev in self.device_status.values() if dev['connected'])
        self.logger.info(f"üìä Connection Summary: {connected_count}/3 devices connected")
        
        if connected_count == 0:
            self.logger.warning("‚ö†Ô∏è No devices connected - check Autoslew status and connections")
            
    def confirm_emergency_shutdown(self):
        """Show confirmation dialogs before emergency shutdown"""
        if self.shutdown_in_progress:
            return
            
        # Check if we have any connected devices
        connected_count = sum(1 for dev in self.device_status.values() if dev['connected'])
        if connected_count == 0:
            messagebox.showwarning(
                "No Devices Connected",
                "No devices are currently connected.\n\n"
                "Emergency shutdown requires at least one connected device.\n"
                "Please check connections first.",
                icon='warning'
            )
            return
            
        # First confirmation
        result1 = messagebox.askyesno(
            "‚ö†Ô∏è EMERGENCY SHUTDOWN CONFIRMATION",
            f"Are you SURE you want to perform emergency shutdown?\n\n"
            f"Connected devices: {connected_count}/3\n\n"
            "This will:\n"
            "‚Ä¢ HALT rotator movement\n"  
            "‚Ä¢ CLOSE telescope covers\n"
            "‚Ä¢ PARK telescope\n"
            "‚Ä¢ Turn OFF telescope motors\n\n"
            "Continue?",
            icon='warning'
        )
        
        if not result1:
            return
            
        # Second confirmation
        result2 = messagebox.askyesno(
            "üö® FINAL CONFIRMATION",
            "LAST CHANCE!\n\n"
            "Are you ABSOLUTELY CERTAIN you want to shutdown the telescope system?\n\n"
            "This action cannot be undone and will stop all telescope operations.\n\n"
            "Only proceed if this is a genuine emergency!",
            icon='error'
        )
        
        if not result2:
            return
            
        # Proceed with shutdown
        self.perform_emergency_shutdown()
        
    def perform_emergency_shutdown(self):
        """Perform the actual emergency shutdown sequence"""
        if self.shutdown_in_progress:
            return
            
        self.shutdown_in_progress = True
        self.shutdown_btn.config(state='disabled', text="SHUTDOWN IN PROGRESS...")
        self.autoslew_btn.config(state='disabled')
        self.manual_btn.config(state='disabled')
        self.progress.start()
        
        # Run shutdown in separate thread
        thread = threading.Thread(target=self._shutdown_worker)
        thread.daemon = True
        thread.start()
        
    def _create_driver_for_shutdown(self, driver_class, config, device_name):
        """Create drivers ONLY during shutdown when absolutely necessary"""
        try:
            self.logger.info(f"üîß Creating {device_name} driver for shutdown...")
            driver = driver_class()
            if driver.connect(config):
                return driver
            else:
                driver.disconnect()
                return None
        except Exception as e:
            self.logger.error(f"‚ùå Failed to create {device_name} driver: {e}")
            return None
        
    def _shutdown_worker(self):
        """Worker thread for emergency shutdown"""
        try:
            self.logger.info("="*50)
            self.logger.info("üö® EMERGENCY SHUTDOWN INITIATED üö®")
            self.logger.info("="*50)
            
            if not DRIVERS_AVAILABLE:
                self.logger.error("‚ùå Cannot perform shutdown - drivers not available")
                return
            
            success_count = 0
            total_operations = 0
            
            # 1. Handle rotator if detected as connected
            if self.device_status['rotator']['connected']:
                self.logger.info("Step 1: Handling rotator shutdown...")
                self.rotator = self._create_driver_for_shutdown(
                    AlpacaRotatorDriver, 
                    self.device_configs['rotator'], 
                    "rotator"
                )
                
                if self.rotator and self.rotator.is_connected():
                    try:
                        if self.rotator.is_moving():
                            total_operations += 1
                            self.logger.info("üõë Rotator is moving - halting...")
                            if self.rotator.halt():
                                self.logger.info("‚úÖ Rotator halted successfully")
                                self.update_status("Rotator", "Halted", "orange")
                                success_count += 1
                            else:
                                self.logger.error("‚ùå Rotator halt failed")
                        else:
                            self.logger.info("‚úÖ Rotator already stationary")
                            self.update_status("Rotator", "Stationary", "green")
                    except Exception as e:
                        self.logger.error(f"‚ùå Rotator halt error: {e}")
                    finally:
                        self.rotator.disconnect()
                        self.rotator = None
                else:
                    self.logger.warning("‚ùå Could not connect to rotator for shutdown")
            else:
                self.logger.info("Step 1: Rotator not connected - skipping")
                
            # 2. Handle cover if detected as connected  
            if self.device_status['cover']['connected']:
                self.logger.info("Step 2: Handling cover shutdown...")
                self.cover = self._create_driver_for_shutdown(
                    AlpacaCoverDriver,
                    self.device_configs['cover'],
                    "cover"
                )
                
                if self.cover and self.cover.is_connected():
                    try:
                        cover_state = self.cover.get_cover_state()
                        if cover_state == "Closed":
                            self.logger.info("‚úÖ Covers already closed")
                            self.update_status("Cover", "Closed", "green")
                        elif cover_state == "Open":
                            total_operations += 1
                            self.logger.info("üîí Closing covers...")
                            if self.cover.close_cover():
                                self.logger.info("‚úÖ Covers closed successfully")
                                self.update_status("Cover", "Closed", "green")
                                success_count += 1
                            else:
                                self.logger.error("‚ùå Cover close failed")
                        else:
                            self.logger.warning(f"‚ö†Ô∏è Cover in {cover_state} state - attempting close...")
                            total_operations += 1
                            if self.cover.close_cover():
                                self.logger.info("‚úÖ Covers closed successfully")
                                self.update_status("Cover", "Closed", "green")
                                success_count += 1
                            else:
                                self.logger.error("‚ùå Cover close failed")
                    except Exception as e:
                        self.logger.error(f"‚ùå Cover operation error: {e}")
                    finally:
                        self.cover.disconnect()
                        self.cover = None
                else:
                    self.logger.warning("‚ùå Could not connect to cover for shutdown")
            else:
                self.logger.info("Step 2: Cover not connected - skipping")
                
            # 3. Handle telescope if detected as connected
            if self.device_status['telescope']['connected']:
                self.logger.info("Step 3: Handling telescope shutdown...")
                self.telescope = self._create_driver_for_shutdown(
                    AlpacaTelescopeDriver,
                    self.device_configs['telescope'],
                    "telescope"
                )
                
                if self.telescope and self.telescope.is_connected():
                    # Check if already parked
                    park_needed = True
                    try:
                        if self.telescope.is_parked():
                            self.logger.info("‚úÖ Telescope already parked")
                            park_needed = False
                        elif self.telescope.is_slewing():
                            self.logger.info("üõë Telescope is slewing - aborting first...")
                            self.telescope.abort_slew()
                            time.sleep(2)
                    except Exception as e:
                        self.logger.warning(f"‚ö†Ô∏è Could not check telescope status: {e} - attempting park")
                        
                    # Park if needed
                    if park_needed:
                        total_operations += 1
                        self.logger.info("üè† Parking telescope...")
                        try:
                            if self.telescope.park(max_wait=60):
                                self.logger.info("‚úÖ Telescope parked successfully")
                                success_count += 1
                            else:
                                self.logger.error("‚ùå Telescope park failed or timed out")
                        except Exception as e:
                            self.logger.error(f"‚ùå Telescope park error: {e}")
                    
                    # Turn off motors
                    total_operations += 1
                    self.logger.info("‚ö° Turning off telescope motors...")
                    try:
                        if self.telescope.motor_off():
                            self.logger.info("‚úÖ Telescope motors turned off")
                            self.update_status("Telescope", "Parked & Motors Off", "green")
                            success_count += 1
                        else:
                            self.logger.error("‚ùå Motor shutdown failed")
                    except Exception as e:
                        self.logger.error(f"‚ùå Motor shutdown error: {e}")
                    
                    # Cleanup
                    self.telescope.disconnect()
                    self.telescope = None
                else:
                    self.logger.warning("‚ùå Could not connect to telescope for shutdown")
            else:
                self.logger.info("Steps 3-4: Telescope not connected - skipping")
                
            # Summary
            self.logger.info("="*50)
            if total_operations == 0:
                self.logger.warning("‚ö†Ô∏è SHUTDOWN COMPLETE - All systems already in safe state")
            elif success_count == total_operations:
                self.logger.info("‚úÖ EMERGENCY SHUTDOWN COMPLETED SUCCESSFULLY")
            else:
                self.logger.warning(f"‚ö†Ô∏è SHUTDOWN PARTIAL - {success_count}/{total_operations} operations successful")
            self.logger.info("="*50)
            
        except Exception as e:
            self.logger.error(f"üö® CRITICAL ERROR during shutdown: {e}")
        finally:
            # Update UI on main thread
            self.root.after(0, self._finish_shutdown)
            
    def _finish_shutdown(self):
        """Finish shutdown on main thread"""
        self.progress.stop()
        self.shutdown_btn.config(text="SHUTDOWN COMPLETE", bg='#6c757d')
        
        # Show completion dialog
        messagebox.showinfo(
            "Shutdown Complete",
            "Emergency shutdown sequence finished.\n\n"
            "Check the activity log above for detailed results.\n\n"
            "You may now close this application.",
            icon='info'
        )
        
    def safe_exit(self):
        """Safely exit the application"""
        if self.shutdown_in_progress:
            if not messagebox.askyesno("Exit During Shutdown?", 
                                     "Shutdown is in progress. Are you sure you want to exit?"):
                return
        
        # Clean exit - no persistent drivers to cleanup
        self.logger.info("Exiting application...")
        self.root.quit()
        self.root.destroy()
        
    def run(self):
        """Start the GUI application"""
        try:
            self.root.mainloop()
        except KeyboardInterrupt:
            self.logger.info("Application interrupted")
        finally:
            # Minimal cleanup needed
            pass


class LogHandler(logging.Handler):
    """Custom log handler to display logs in the GUI"""
    
    def __init__(self, gui):
        super().__init__()
        self.gui = gui
        
    def emit(self, record):
        """Emit a log record to the GUI"""
        try:
            msg = self.format(record)
            # Schedule GUI update on main thread
            self.gui.root.after(0, lambda: self._update_log_display(msg))
        except Exception:
            pass
            
    def _update_log_display(self, message):
        """Update log display widget"""
        try:
            self.gui.log_display.config(state='normal')
            self.gui.log_display.insert(tk.END, message + '\n')
            self.gui.log_display.see(tk.END)
            self.gui.log_display.config(state='disabled')
        except Exception:
            pass


def main():
    """Main entry point"""
    if not DRIVERS_AVAILABLE:
        print("ERROR: Required device drivers not found!")
        print("Make sure alpaca_telescope.py, alpaca_rotator.py, and alpaca_cover.py are in the same directory.")
        input("Press Enter to exit...")
        return 1
        
    try:
        app = EmergencyShutdownGUI()
        app.run()
        return 0
    except Exception as e:
        print(f"Application error: {e}")
        input("Press Enter to exit...")
        return 1


if __name__ == "__main__":
    sys.exit(main())
