#!/usr/bin/env python3
"""
Emergency Telescope Shutdown Tool
Safely shuts down telescope system after TCU restart or other emergencies.
FIXED: Completely avoids DLL conflicts by using HTTP-only checks during startup
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import subprocess
import time
import threading
import logging
import sys
from pathlib import Path
import psutil
import os
import requests
import json
from typing import Optional, Dict, Any

# Import your existing drivers (assuming they're in the same directory or Python path)
try:
    from alpaca_telescope import AlpacaTelescopeDriver, AlpacaTelescopeError
    from alpaca_rotator import AlpacaRotatorDriver, AlpacaRotatorError  
    from alpaca_cover import AlpacaCoverDriver, AlpacaCoverError
    DRIVERS_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Could not import drivers: {e}")
    DRIVERS_AVAILABLE = False

class EmergencyShutdownGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Emergency Telescope Shutdown")
        self.root.geometry("700x800")
        self.root.configure(bg='#f0f0f0')
        
        # Make window stay on top initially
        self.root.attributes('-topmost', True)
        
        # Device configurations (from your devices.yaml)
        self.device_configs = {
            'telescope': {
                'address': '127.0.0.1:11111',
                'device_number': 0,
                'settle_time': 2.0
            },
            'rotator': {
                'address': '127.0.0.1:11112', 
                'device_number': 0,
                'settle_time': 0.1,
                'mechanical_limits': {'min_deg': 94.0, 'max_deg': 320.0}
            },
            'cover': {
                'address': '127.0.0.1:11112',
                'device_number': 0,
                'operation_timeout': 30.0,
                'settle_time': 15.0
            }
        }
        
        self.autoslew_path = r"C:\Program Files (x86)\Autoslew\Autoslew.exe"
        
        # CRITICAL CHANGE: NO driver instances created until shutdown!
        self.telescope = None
        self.rotator = None  
        self.cover = None
        
        # Device status via HTTP only
        self.device_status = {
            'telescope': {'connected': False, 'info': {}},
            'rotator': {'connected': False, 'info': {}},
            'cover': {'connected': False, 'info': {}}
        }
        
        # GUI state
        self.shutdown_in_progress = False
        self.autoslew_started = False
        
        self.setup_logging()
        self.create_widgets()
        self.center_window()
        
    def setup_logging(self):
        """Setup logging to display in GUI"""
        self.log_handler = LogHandler(self)
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[self.log_handler]
        )
        self.logger = logging.getLogger(__name__)
        
    def create_widgets(self):
        """Create the GUI widgets"""
        
        # Title
        title_frame = tk.Frame(self.root, bg='#d32f2f', height=60)
        title_frame.pack(fill='x', padx=5, pady=5)
        title_frame.pack_propagate(False)
        
        title_label = tk.Label(
            title_frame, 
            text="‚ö†Ô∏è EMERGENCY TELESCOPE SHUTDOWN ‚ö†Ô∏è", 
            font=('Arial', 14, 'bold'),
            fg='white', 
            bg='#d32f2f'
        )
        title_label.pack(expand=True)
        
        # Warning text
        warning_frame = tk.Frame(self.root, bg='#fff3cd', relief='solid', bd=1)
        warning_frame.pack(fill='x', padx=10, pady=5)
        
        warning_text = tk.Text(
            warning_frame, 
            height=4, 
            bg='#fff3cd', 
            fg='#856404',
            font=('Arial', 10),
            relief='flat',
            wrap='word'
        )
        warning_text.pack(fill='x', padx=10, pady=10)
        warning_text.insert('1.0', 
            "‚ö†Ô∏è  This tool performs emergency shutdown of telescope systems.\n"
            "‚ö†Ô∏è  Use only after TCU restart or system failure.\n"
            "‚ö†Ô∏è  This will STOP rotator, CLOSE covers, PARK telescope, and turn OFF motors.\n"
            "‚ö†Ô∏è  Multiple confirmations required - do not use during normal operations!")
        warning_text.config(state='disabled')
        
        # Buttons frame
        button_frame = tk.Frame(self.root, bg='#f0f0f0')
        button_frame.pack(fill='x', padx=10, pady=10)
        
        # Start Autoslew button
        self.autoslew_btn = tk.Button(
            button_frame,
            text="1. Start Autoslew & Check Connections",
            command=self.start_autoslew_and_check,
            bg='#4CAF50',
            fg='white',
            font=('Arial', 11, 'bold'),
            height=2
        )
        self.autoslew_btn.pack(fill='x', pady=5)
        
        # Emergency shutdown button (initially disabled)
        self.shutdown_btn = tk.Button(
            button_frame,
            text="2. EMERGENCY SHUTDOWN",
            command=self.confirm_emergency_shutdown,
            bg='#d32f2f',
            fg='white', 
            font=('Arial', 11, 'bold'),
            height=2,
            state='disabled'
        )
        self.shutdown_btn.pack(fill='x', pady=5)
        
        # Exit button
        self.exit_btn = tk.Button(
            button_frame,
            text="Exit",
            command=self.safe_exit,
            bg='#6c757d',
            fg='white',
            font=('Arial', 10)
        )
        self.exit_btn.pack(fill='x', pady=5)
        
        # Status frame
        status_frame = tk.LabelFrame(self.root, text="System Status", bg='#f0f0f0', font=('Arial', 10, 'bold'))
        status_frame.pack(fill='x', padx=10, pady=5)
        
        # Status labels
        self.status_labels = {}
        for device in ['Autoslew', 'Telescope', 'Rotator', 'Cover']:
            frame = tk.Frame(status_frame, bg='#f0f0f0')
            frame.pack(fill='x', padx=5, pady=2)
            
            label = tk.Label(frame, text=f"{device}:", bg='#f0f0f0', font=('Arial', 9))
            label.pack(side='left')
            
            status = tk.Label(frame, text="Not Connected", bg='#f0f0f0', fg='red', font=('Arial', 9, 'bold'))
            status.pack(side='right')
            
            self.status_labels[device] = status
            
        # Log display
        log_frame = tk.LabelFrame(self.root, text="Activity Log", bg='#f0f0f0', font=('Arial', 10, 'bold'))
        log_frame.pack(fill='both', expand=True, padx=10, pady=5)
        
        self.log_display = scrolledtext.ScrolledText(
            log_frame, 
            height=10, 
            bg='black', 
            fg='lime',
            font=('Consolas', 9),
            state='disabled'
        )
        self.log_display.pack(fill='both', expand=True, padx=5, pady=5)
        
        # Progress bar
        self.progress = ttk.Progressbar(self.root, mode='indeterminate')
        self.progress.pack(fill='x', padx=10, pady=5)
        
        self.logger.info("Emergency Shutdown Tool initialized")
        self.logger.info("Click 'Start Autoslew & Check Connections' to begin")
        
    def center_window(self):
        """Center window on screen"""
        self.root.update_idletasks()
        x = (self.root.winfo_screenwidth() // 2) - (self.root.winfo_width() // 2)
        y = (self.root.winfo_screenheight() // 2) - (self.root.winfo_height() // 2)
        self.root.geometry(f"+{x}+{y}")
        
    def update_status(self, device: str, status: str, color: str = 'red'):
        """Update device status display"""
        if device in self.status_labels:
            self.status_labels[device].config(text=status, fg=color)
            
    def is_autoslew_running(self) -> bool:
        """Check if Autoslew is already running"""
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                if 'autoslew' in proc.info['name'].lower():
                    return True
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        return False
        
    def start_autoslew_and_check(self):
        """Start Autoslew and check device connections"""
        if self.shutdown_in_progress:
            return
            
        # Disable button and start progress
        self.autoslew_btn.config(state='disabled')
        self.progress.start()
        
        # Run in separate thread
        thread = threading.Thread(target=self._autoslew_and_check_worker)
        thread.daemon = True
        thread.start()
        
    def _http_get_device_info(self, address: str, device_type: str, device_number: int, property_name: str):
        """
        CRITICAL FIX: Use ONLY HTTP requests - no driver instantiation
        """
        try:
            url = f"http://{address}/api/v1/{device_type}/{device_number}/{property_name}"
            response = requests.get(url, timeout=3)
            if response.status_code == 200:
                data = response.json()
                return data.get('Value'), None
            else:
                return None, f"HTTP {response.status_code}"
        except Exception as e:
            return None, str(e)
            
    def _http_check_device_connected(self, address: str, device_type: str, device_number: int):
        """Check if device is connected via HTTP only"""
        try:
            url = f"http://{address}/api/v1/{device_type}/{device_number}/connected"
            response = requests.get(url, timeout=3)
            if response.status_code == 200:
                data = response.json()
                return data.get('Value', False)
            return False
        except:
            return False
            
    def _check_alpaca_service_ready(self, address, device_type, device_number):
        """Check if ALPACA service responds"""
        return self._http_check_device_connected(address, device_type, device_number) is not None
        
    def _autoslew_and_check_worker(self):
        """Worker thread for Autoslew startup and HTTP-only connection checking"""
        try:
            self.logger.info("üöÄ Starting Autoslew launch sequence...")
            
            # Check if Autoslew is already running
            if self.is_autoslew_running():
                self.logger.info("‚úÖ Autoslew is already running")
                self.update_status("Autoslew", "Running", "green")
                self.autoslew_started = True
            else:
                self.logger.info("üîß Starting Autoslew...")
                self.update_status("Autoslew", "Starting...", "orange")
                
                if not os.path.exists(self.autoslew_path):
                    raise FileNotFoundError(f"Autoslew not found at: {self.autoslew_path}")
                    
                # Start Autoslew with detached process
                subprocess.Popen([
                    self.autoslew_path
                ], shell=True, 
                   creationflags=subprocess.CREATE_NEW_PROCESS_GROUP | subprocess.DETACHED_PROCESS,
                   stdin=subprocess.PIPE, 
                   stdout=subprocess.PIPE, 
                   stderr=subprocess.PIPE)
                
                self.logger.warning("üî• IMPORTANT: Allow Autoslew through any Windows firewall/security prompts!")
                
                # Wait for Autoslew process to start
                max_wait = 45
                for i in range(max_wait):
                    if i % 5 == 0 and i > 0:
                        self.logger.info(f"‚è≥ Waiting for Autoslew process... {i}/{max_wait} seconds")
                    if self.is_autoslew_running():
                        self.logger.info("‚úÖ Autoslew process detected")
                        self.autoslew_started = True
                        break
                    time.sleep(1)
                else:
                    raise TimeoutError("‚ùå Autoslew failed to start within 45 seconds")
                    
                self.update_status("Autoslew", "Running", "green")
            
            # CRITICAL: Wait for Autoslew to fully initialize ALL drivers
            self.logger.info("‚è≥ Waiting for Autoslew to fully initialize drivers...")
            self.logger.info("   This prevents DLL conflicts by ensuring Autoslew gets exclusive access first")
            
            max_service_wait = 120  # 2 minutes max
            service_ready = False
            
            for attempt in range(0, max_service_wait, 10):
                self.logger.info(f"üîç Testing ALPACA services... ({attempt}/{max_service_wait}s)")
                
                # Test each service
                telescope_ready = self._check_alpaca_service_ready("127.0.0.1:11111", "telescope", 0)
                rotator_ready = self._check_alpaca_service_ready("127.0.0.1:11112", "rotator", 0)  
                cover_ready = self._check_alpaca_service_ready("127.0.0.1:11112", "covercalibrator", 0)
                
                if telescope_ready and (rotator_ready or cover_ready):  # At least telescope + one other
                    self.logger.info("‚úÖ ALPACA services are responding!")
                    service_ready = True
                    break
                    
                if attempt < max_service_wait - 10:
                    time.sleep(10)
            
            if not service_ready:
                self.logger.warning("‚ö†Ô∏è ALPACA services may not be fully ready - proceeding with caution")
            
            # Additional safety buffer - critical for avoiding DLL conflicts
            self.logger.info("üõ°Ô∏è Safety buffer: Waiting additional 20 seconds for complete driver initialization...")
            time.sleep(20)
            
            # Now check device status using HTTP ONLY - no driver creation
            self.logger.info("üîç Checking device status via HTTP (no DLL conflicts)...")
            self._check_all_connections_http_only()
            
        except Exception as e:
            self.logger.error(f"‚ùå Failed during Autoslew startup: {e}")
        finally:
            # Re-enable UI on main thread
            self.root.after(0, self._finish_autoslew_check)
            
    def _finish_autoslew_check(self):
        """Finish Autoslew check on main thread"""
        self.progress.stop()
        self.autoslew_btn.config(state='normal')
        
        # Enable shutdown button if Autoslew is running
        if self.autoslew_started:
            self.shutdown_btn.config(state='normal')
            
    def _check_all_connections_http_only(self):
        """
        CRITICAL FIX: Check connections using ONLY HTTP requests
        No driver instantiation = No DLL conflicts
        """
        
        # Check telescope via HTTP
        self.logger.info("üî≠ Checking telescope via HTTP...")
        try:
            connected = self._http_check_device_connected("127.0.0.1:11111", "telescope", 0)
            if connected:
                # Get telescope info
                name, err = self._http_get_device_info("127.0.0.1:11111", "telescope", 0, "name")
                description, _ = self._http_get_device_info("127.0.0.1:11111", "telescope", 0, "description")
                
                tel_name = name or description or "Unknown Telescope"
                self.logger.info(f"‚úÖ Telescope connected: {tel_name}")
                self.update_status("Telescope", f"Connected - {tel_name}", "green")
                self.device_status['telescope']['connected'] = True
                self.device_status['telescope']['info'] = {'name': tel_name}
            else:
                self.logger.warning("‚ùå Telescope not connected")
                self.update_status("Telescope", "Not Connected", "red")
                
        except Exception as e:
            self.logger.warning(f"‚ùå Telescope HTTP check failed: {e}")
            self.update_status("Telescope", "Check Failed", "red")
            
        # Check rotator via HTTP
        self.logger.info("üîÑ Checking rotator via HTTP...")
        try:
            connected = self._http_check_device_connected("127.0.0.1:11112", "rotator", 0)
            if connected:
                # Get rotator position
                position, err = self._http_get_device_info("127.0.0.1:11112", "rotator", 0, "position")
                name, _ = self._http_get_device_info("127.0.0.1:11112", "rotator", 0, "name")
                
                pos_deg = position if position is not None else 0.0
                rot_name = name or "Unknown Rotator"
                self.logger.info(f"‚úÖ Rotator connected: {rot_name} at {pos_deg:.1f}¬∞")
                self.update_status("Rotator", f"Connected - {pos_deg:.1f}¬∞", "green")
                self.device_status['rotator']['connected'] = True
                self.device_status['rotator']['info'] = {'name': rot_name, 'position_deg': pos_deg}
            else:
                self.logger.warning("‚ùå Rotator not connected")
                self.update_status("Rotator", "Not Connected", "red")
                
        except Exception as e:
            self.logger.warning(f"‚ùå Rotator HTTP check failed: {e}")
            self.update_status("Rotator", "Check Failed", "red")
            
        # Check cover via HTTP
        self.logger.info("üõ°Ô∏è Checking cover via HTTP...")
        try:
            connected = self._http_check_device_connected("127.0.0.1:11112", "covercalibrator", 0)
            if connected:
                # Get cover state
                cover_state, err = self._http_get_device_info("127.0.0.1:11112", "covercalibrator", 0, "coverstate")
                name, _ = self._http_get_device_info("127.0.0.1:11112", "covercalibrator", 0, "name")
                
                # Cover state mapping (ASCOM standard)
                state_map = {0: "Unknown", 1: "Closed", 2: "Moving", 3: "Open", 4: "Error"}
                state_name = state_map.get(cover_state, f"State{cover_state}")
                
                cover_name = name or "Unknown Cover"
                self.logger.info(f"‚úÖ Cover connected: {cover_name} - {state_name}")
                
                color = "green" if state_name == "Closed" else "orange" if state_name == "Open" else "red"
                self.update_status("Cover", f"Connected - {state_name}", color)
                self.device_status['cover']['connected'] = True
                self.device_status['cover']['info'] = {'name': cover_name, 'cover_state': state_name}
            else:
                self.logger.warning("‚ùå Cover not connected")
                self.update_status("Cover", "Not Connected", "red")
                
        except Exception as e:
            self.logger.warning(f"‚ùå Cover HTTP check failed: {e}")
            self.update_status("Cover", "Check Failed", "red")
        
        # Summary
        connected_count = sum(1 for dev in self.device_status.values() if dev['connected'])
        self.logger.info(f"üìä Connection Summary: {connected_count}/3 devices connected via HTTP")
            
    def confirm_emergency_shutdown(self):
        """Show confirmation dialogs before emergency shutdown"""
        if self.shutdown_in_progress:
            return
            
        # First confirmation
        result1 = messagebox.askyesno(
            "‚ö†Ô∏è EMERGENCY SHUTDOWN CONFIRMATION",
            "Are you SURE you want to perform emergency shutdown?\n\n"
            "This will:\n"
            "‚Ä¢ HALT rotator movement\n"  
            "‚Ä¢ CLOSE telescope covers\n"
            "‚Ä¢ PARK telescope\n"
            "‚Ä¢ Turn OFF telescope motors\n\n"
            "Continue?",
            icon='warning'
        )
        
        if not result1:
            return
            
        # Second confirmation (more serious)
        result2 = messagebox.askyesno(
            "üö® FINAL CONFIRMATION",
            "LAST CHANCE!\n\n"
            "Are you ABSOLUTELY CERTAIN you want to shutdown the telescope system?\n\n"
            "This action cannot be undone and will stop all telescope operations.\n\n"
            "Only proceed if this is a genuine emergency!",
            icon='error'
        )
        
        if not result2:
            return
            
        # Proceed with shutdown
        self.perform_emergency_shutdown()
        
    def perform_emergency_shutdown(self):
        """Perform the actual emergency shutdown sequence"""
        if self.shutdown_in_progress:
            return
            
        self.shutdown_in_progress = True
        self.shutdown_btn.config(state='disabled', text="SHUTDOWN IN PROGRESS...")
        self.autoslew_btn.config(state='disabled')
        self.progress.start()
        
        # Run shutdown in separate thread
        thread = threading.Thread(target=self._shutdown_worker)
        thread.daemon = True
        thread.start()
        
    def _create_driver_for_shutdown(self, driver_class, config, device_name):
        """
        ONLY create drivers during shutdown when absolutely necessary
        """
        try:
            self.logger.info(f"üîß Creating {device_name} driver for shutdown operations...")
            driver = driver_class()
            if driver.connect(config):
                return driver
            else:
                driver.disconnect()
                return None
        except Exception as e:
            self.logger.error(f"‚ùå Failed to create {device_name} driver: {e}")
            return None
        
    def _shutdown_worker(self):
        """Worker thread for emergency shutdown - drivers created ONLY here"""
        try:
            self.logger.info("="*50)
            self.logger.info("üö® EMERGENCY SHUTDOWN INITIATED üö®")
            self.logger.info("="*50)
            
            if not DRIVERS_AVAILABLE:
                self.logger.error("‚ùå Cannot perform shutdown - drivers not available")
                return
            
            success_count = 0
            total_operations = 0
            
            # 1. Handle rotator if it was detected as connected
            if self.device_status['rotator']['connected']:
                self.logger.info("Step 1: Creating rotator driver for shutdown...")
                self.rotator = self._create_driver_for_shutdown(
                    AlpacaRotatorDriver, 
                    self.device_configs['rotator'], 
                    "rotator"
                )
                
                if self.rotator and self.rotator.is_connected():
                    try:
                        if self.rotator.is_moving():
                            total_operations += 1
                            self.logger.info("üõë Rotator is moving - halting...")
                            if self.rotator.halt():
                                self.logger.info("‚úÖ Rotator halted successfully")
                                self.update_status("Rotator", "Halted", "orange")
                                success_count += 1
                            else:
                                self.logger.error("‚ùå Rotator halt failed")
                        else:
                            self.logger.info("‚úÖ Rotator already stationary")
                            self.update_status("Rotator", "Stationary", "green")
                    except Exception as e:
                        self.logger.error(f"‚ùå Rotator halt error: {e}")
                    finally:
                        self.rotator.disconnect()
                        self.rotator = None
                else:
                    self.logger.warning("‚ùå Could not connect to rotator for shutdown")
            else:
                self.logger.info("Step 1: Rotator not detected - skipping")
                
            # 2. Handle cover if it was detected as connected  
            if self.device_status['cover']['connected']:
                self.logger.info("Step 2: Creating cover driver for shutdown...")
                self.cover = self._create_driver_for_shutdown(
                    AlpacaCoverDriver,
                    self.device_configs['cover'],
                    "cover"
                )
                
                if self.cover and self.cover.is_connected():
                    try:
                        cover_state = self.cover.get_cover_state()
                        if cover_state == "Closed":
                            self.logger.info("‚úÖ Covers already closed")
                            self.update_status("Cover", "Closed", "green")
                        elif cover_state == "Open":
                            total_operations += 1
                            self.logger.info("üîí Closing covers...")
                            if self.cover.close_cover():
                                self.logger.info("‚úÖ Covers closed successfully")
                                self.update_status("Cover", "Closed", "green")
                                success_count += 1
                            else:
                                self.logger.error("‚ùå Cover close failed")
                        else:
                            self.logger.warning(f"‚ö†Ô∏è Cover in {cover_state} state - attempting close...")
                            total_operations += 1
                            if self.cover.close_cover():
                                self.logger.info("‚úÖ Covers closed successfully")
                                self.update_status("Cover", "Closed", "green")
                                success_count += 1
                            else:
                                self.logger.error("‚ùå Cover close failed")
                    except Exception as e:
                        self.logger.error(f"‚ùå Cover operation error: {e}")
                    finally:
                        self.cover.disconnect()
                        self.cover = None
                else:
                    self.logger.warning("‚ùå Could not connect to cover for shutdown")
            else:
                self.logger.info("Step 2: Cover not detected - skipping")
                
            # 3. Handle telescope if it was detected as connected
            if self.device_status['telescope']['connected']:
                self.logger.info("Step 3: Creating telescope driver for shutdown...")
                self.telescope = self._create_driver_for_shutdown(
                    AlpacaTelescopeDriver,
                    self.device_configs['telescope'],
                    "telescope"
                )
                
                if self.telescope and self.telescope.is_connected():
                    # Check if already parked
                    park_needed = True
                    try:
                        if self.telescope.is_parked():
                            self.logger.info("‚úÖ Telescope already parked")
                            park_needed = False
                        elif self.telescope.is_slewing():
                            self.logger.info("üõë Telescope is slewing - aborting first...")
                            self.telescope.abort_slew()
                            time.sleep(2)
                    except Exception as e:
                        self.logger.warning(f"‚ö†Ô∏è Could not check telescope status: {e} - attempting park")
                        
                    # Park if needed
                    if park_needed:
                        total_operations += 1
                        self.logger.info("üè† Parking telescope...")
                        try:
                            if self.telescope.park(max_wait=60):
                                self.logger.info("‚úÖ Telescope parked successfully")
                                success_count += 1
                            else:
                                self.logger.error("‚ùå Telescope park failed or timed out")
                        except Exception as e:
                            self.logger.error(f"‚ùå Telescope park error: {e}")
                    
                    # Turn off motors
                    total_operations += 1
                    self.logger.info("‚ö° Turning off telescope motors...")
                    try:
                        if self.telescope.motor_off():
                            self.logger.info("‚úÖ Telescope motors turned off")
                            self.update_status("Telescope", "Parked & Motors Off", "green")
                            success_count += 1
                        else:
                            self.logger.error("‚ùå Motor shutdown failed")
                    except Exception as e:
                        self.logger.error(f"‚ùå Motor shutdown error: {e}")
                    
                    # Cleanup
                    self.telescope.disconnect()
                    self.telescope = None
                else:
                    self.logger.warning("‚ùå Could not connect to telescope for shutdown")
            else:
                self.logger.info("Steps 3-4: Telescope not detected - skipping")
                
            # Summary
            self.logger.info("="*50)
            if total_operations == 0:
                self.logger.warning("‚ö†Ô∏è SHUTDOWN COMPLETE - All systems already in safe state")
            elif success_count == total_operations:
                self.logger.info("‚úÖ EMERGENCY SHUTDOWN COMPLETED SUCCESSFULLY")
            else:
                self.logger.warning(f"‚ö†Ô∏è SHUTDOWN PARTIAL - {success_count}/{total_operations} operations successful")
            self.logger.info("="*50)
            
        except Exception as e:
            self.logger.error(f"üö® CRITICAL ERROR during shutdown: {e}")
        finally:
            # Update UI on main thread
            self.root.after(0, self._finish_shutdown)
            
    def _finish_shutdown(self):
        """Finish shutdown on main thread"""
        self.progress.stop()
        self.shutdown_btn.config(text="SHUTDOWN COMPLETE", bg='#6c757d')
        
        # Show completion dialog
        messagebox.showinfo(
            "Shutdown Complete",
            "Emergency shutdown sequence finished.\n\n"
            "Check the activity log above for detailed results.\n\n"
            "You may now close this application.",
            icon='info'
        )
        
    def safe_exit(self):
        """Safely exit the application"""
        if self.shutdown_in_progress:
            if not messagebox.askyesno("Exit During Shutdown?", 
                                     "Shutdown is in progress. Are you sure you want to exit?"):
                return
        
        # Clean exit - no drivers to cleanup since they're only created during shutdown
        self.logger.info("Exiting application...")
        self.root.quit()
        self.root.destroy()
        
    def run(self):
        """Start the GUI application"""
        try:
            self.root.mainloop()
        except KeyboardInterrupt:
            self.logger.info("Application interrupted")
        finally:
            # Minimal cleanup needed since no persistent driver connections
            pass


class LogHandler(logging.Handler):
    """Custom log handler to display logs in the GUI"""
    
    def __init__(self, gui):
        super().__init__()
        self.gui = gui
        
    def emit(self, record):
        """Emit a log record to the GUI"""
        try:
            msg = self.format(record)
            # Schedule GUI update on main thread
            self.gui.root.after(0, lambda: self._update_log_display(msg))
        except Exception:
            pass
            
    def _update_log_display(self, message):
        """Update log display widget"""
        try:
            self.gui.log_display.config(state='normal')
            self.gui.log_display.insert(tk.END, message + '\n')
            self.gui.log_display.see(tk.END)
            self.gui.log_display.config(state='disabled')
        except Exception:
            pass


def main():
    """Main entry point"""
    if not DRIVERS_AVAILABLE:
        print("ERROR: Required device drivers not found!")
        print("Make sure alpaca_telescope.py, alpaca_rotator.py, and alpaca_cover.py are in the same directory.")
        input("Press Enter to exit...")
        return 1
        
    try:
        app = EmergencyShutdownGUI()
        app.run()
        return 0
    except Exception as e:
        print(f"Application error: {e}")
        input("Press Enter to exit...")
        return 1


if __name__ == "__main__":
    sys.exit(main())
