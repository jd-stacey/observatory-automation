# Add these methods to the PlatesolveCorrector class in corrector.py

class PlatesolveCorrector:
    
    def __init__(self, telescope_driver, config_loader, rotator_driver=None, store_last_measurements=False):
        self.telescope_driver = telescope_driver
        self.config_loader = config_loader
        self.last_processed_file = ""
        self.last_applied_sequence = -1
        self.last_target_id = None
        self.last_failed_filename = None
        self.min_acceptable_sequence = 0
        
        # ADD THESE NEW FIELDS for target tracking
        self.current_target_id = None  # Track expected target
        self.session_start_time = None  # Track when session started
        
        self.cumulative_zero_time = 0
        self.rotator_driver = rotator_driver
        
        # ... rest of init stays the same ...
    
    def set_current_target(self, target_id: str):
        """Set the expected target ID for validation"""
        if self.current_target_id != target_id:
            self.current_target_id = target_id
            self.session_start_time = time.time()
            
            # Try to delete old platesolve data
            if self.json_file_path.exists():
                try:
                    self.json_file_path.unlink()
                    logger.info(f"Deleted old platesolve data for new target: {target_id}")
                except PermissionError:
                    logger.debug("Could not delete platesolve JSON (file in use)")
                except Exception as e:
                    logger.warning(f"Could not delete old platesolve JSON: {e}")
            
            # Reset tracking
            self.last_applied_sequence = -1
            self.last_processed_file = ""
            self.last_target_id = None
            self.min_acceptable_sequence = 0
            self.last_failed_filename = None
            
            logger.info(f"Set current target: {target_id}")
    
    def _normalize_target_id(self, target_id: str) -> str:
        """Normalize target ID for comparison (remove dashes, pluses)"""
        if not target_id:
            return ""
        return target_id.replace('-', '').replace('+', '').upper()
    
    def _extract_target_from_filename(self, filename: str) -> Optional[str]:
        """Extract target ID from filename"""
        basename = Path(filename).name
        # Match pattern: TARGETID_FILTER_YYYYMMDD_HHMMSS_XXs_NNNNN.fits
        # or: TARGETID_YYYYMMDD_HHMMSS_XXs_NNNNN.fits
        match = re.match(r'^(.+?)_[A-Z]?_?\d{8}_', basename)
        if match:
            return match.group(1)
        # Fallback pattern without filter
        match = re.match(r'^(.+?)_\d{8}_', basename)
        return match.group(1) if match else None
    
    def is_platesolve_for_current_target(self, data: Dict[str, Any]) -> bool:
        """Check if platesolve data is for the current target"""
        try:
            # If no target set, accept anything (backwards compatibility)
            if not self.current_target_id:
                logger.debug("No current target set - accepting platesolve")
                return True
            
            # Check if platesolve is from current session
            if self.session_start_time is not None:
                try:
                    json_mtime = self.json_file_path.stat().st_mtime
                    if json_mtime < self.session_start_time:
                        logger.debug(f"Platesolve predates current session - rejecting "
                                   f"(JSON age: {time.time() - json_mtime:.1f}s, "
                                   f"session age: {time.time() - self.session_start_time:.1f}s)")
                        return False
                except Exception as e:
                    logger.warning(f"Could not check platesolve file time: {e}")
            
            # Extract target from platesolve filename
            solved_filename = data.get('fitsname', {}).get("0", "")
            if not solved_filename:
                logger.debug("No filename in platesolve data")
                return False
            
            solved_target = self._extract_target_from_filename(solved_filename)
            if not solved_target:
                logger.debug("Could not extract target from platesolve filename")
                return False
            
            # Normalize both for comparison
            solved_norm = self._normalize_target_id(solved_target)
            current_norm = self._normalize_target_id(self.current_target_id)
            
            if solved_norm != current_norm:
                logger.warning(f"Platesolve target mismatch! "
                             f"Expected: {self.current_target_id}, "
                             f"Got: {solved_target} "
                             f"(from file: {Path(solved_filename).name})")
                return False
            
            logger.debug(f"Platesolve target matches: {solved_target}")
            return True
            
        except Exception as e:
            logger.warning(f"Error validating platesolve target: {e}")
            return False  # Reject on validation errors
    
    def apply_single_correction(self, timeout_seconds: Optional[float] = None,
                                latest_captured_sequence: Optional[int] = None) -> CorrectionResult:
        try:
            if not self.telescope_driver.is_connected():
                return CorrectionResult(
                    applied=False, ra_offset_arcsec=0.0, dec_offset_arcsec=0.0, 
                    rotation_offset_deg=0.0, total_offset_arcsec=0.0, settle_time=0.0, 
                    reason="Telescope not connected"
                )
                
            file_ready, data = self.check_json_file_ready()
            
            if not file_ready:
                if timeout_seconds and timeout_seconds > 0:
                    logger.info(f"Waiting up to {timeout_seconds} s for platesolve data...")
                    start_time = time.time()
                    check_interval = self.platesolve_config.get('check_interval_seconds', 5)
                    
                    while True:
                        file_ready, data = self.check_json_file_ready()
                        if file_ready:
                            break
                        elapsed = time.time() - start_time
                        remaining = timeout_seconds - elapsed
                        if remaining <= 0:
                            break
                        logger.debug(f"Waiting for platesolve file... {elapsed:.1f} / {timeout_seconds} s elapsed")
                        time.sleep(min(check_interval, remaining))
                        
                if not file_ready:
                    return CorrectionResult(
                        applied=False, ra_offset_arcsec=0.0, dec_offset_arcsec=0.0, 
                        rotation_offset_deg=0.0, total_offset_arcsec=0.0, settle_time=0.0, 
                        reason="No recent platesolve data available"
                    )
            
            # **NEW: Validate target BEFORE processing**
            if not self.is_platesolve_for_current_target(data):
                return CorrectionResult(
                    applied=False, ra_offset_arcsec=0.0, dec_offset_arcsec=0.0,
                    rotation_offset_deg=0.0, total_offset_arcsec=0.0, settle_time=0.0,
                    reason="Platesolve is for different target - rejecting"
                )
            
            current_filename = data.get('fitsname', {}).get("0", "")
            
            # Check 1: Exact filename match (prevents duplicate processing)
            if current_filename == self.last_processed_file:
                return CorrectionResult(
                    applied=False, ra_offset_arcsec=0.0, dec_offset_arcsec=0.0,
                    rotation_offset_deg=0.0, total_offset_arcsec=0.0, settle_time=0.0,
                    reason="Already processed this solution"
                )
            
            # ... rest of the method continues as before ...
            # (The rest of your existing apply_single_correction code)
            
        except PlatesolveCorrectorError:
            raise
        except Exception as e:
            logger.error(f"Unexpected error in correction: {e}")    
            raise PlatesolveCorrectorError(f"Correction failed: {e}")
