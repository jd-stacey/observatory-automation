def check_wrap_needed(self):
    """Check if rotator will hit limits soon - with proper logic"""
    if not self.fr_config['wrap_management']['enabled']:
        return False      

    current_pos = self.rotator.get_position()
    margin = self.fr_config['wrap_management']['flip_margin_deg']
    
    # Simple, reliable check: are we actually near a mechanical limit?
    near_min_limit = current_pos < (self.rotator.min_limit + margin)
    near_max_limit = current_pos > (self.rotator.max_limit - margin)
    
    if near_min_limit or near_max_limit:
        logger.info(f"[wrap-check] Near limit: pos={current_pos:.1f}°, "
                   f"limits={self.rotator.min_limit:.1f}°-{self.rotator.max_limit:.1f}°, "
                   f"margin={margin:.1f}°")
        return True
        
    # Additional check: look ahead only if we're rotating in a problematic direction
    lookahead_min = self.fr_config['wrap_management']['lookahead_minutes']
    current_time = Time.now()
    future_time = current_time + lookahead_min * u.minute
    
    current_pa = self.calculate_required_pa(current_time)
    future_pa = self.calculate_required_pa(future_time)
    
    if current_pa is None or future_pa is None:
        return False
        
    current_calc_pos = self.pa_to_rotator_position(current_pa)
    future_calc_pos = self.pa_to_rotator_position(future_pa)
    
    # Calculate rotation direction and rate
    pa_rate = (future_pa - current_pa) / lookahead_min  # degrees per minute
    
    # Only trigger if we're rotating toward a limit AND will hit it soon
    if pa_rate > 0.1:  # Rotating toward higher angles
        time_to_max = (self.rotator.max_limit - margin - current_pos) / pa_rate
        if 0 < time_to_max < lookahead_min * 2:  # Will hit limit soon
            logger.info(f"[wrap-check] Future limit approach: rate={pa_rate:.2f}°/min, "
                       f"time_to_limit={time_to_max:.1f}min")
            return True
            
    elif pa_rate < -0.1:  # Rotating toward lower angles
        time_to_min = (current_pos - self.rotator.min_limit - margin) / (-pa_rate)
        if 0 < time_to_min < lookahead_min * 2:  # Will hit limit soon
            logger.info(f"[wrap-check] Future limit approach: rate={pa_rate:.2f}°/min, "
                       f"time_to_limit={time_to_min:.1f}min")
            return True
    
    return False
