#!/usr/bin/env python3
"""
Adaptive Exposure Test Generator for spectroscopy system
Focuses specifically on testing platesolve failure -> exposure increase -> recovery cycles
"""

import json
import time
import random
import math
from pathlib import Path
from datetime import datetime, timezone
from typing import Dict, Any
import argparse

# Test configuration
PLATESOLVE_JSON = Path("P:/temp/wcssolution_2.json")
MIRROR_JSON = Path("P:/temp/mirror_telescope.json")

class AdaptiveExposureTestGenerator:
    def __init__(self):
        self.current_target = None
        self.target_start_time = None
        self.frame_counter = 0
        self.test_phase = "initial"
        self.phase_counter = 0
        
        # Test phases for adaptive exposure testing
        self.test_phases = [
            {"name": "initial_failure", "duration_frames": 3, "pattern": "all_zeros"},
            {"name": "continued_failure", "duration_frames": 2, "pattern": "all_zeros"}, 
            {"name": "recovery", "duration_frames": 3, "pattern": "small_offsets"},
            {"name": "normal_operation", "duration_frames": 5, "pattern": "random_small"},
            {"name": "new_failure_cycle", "duration_frames": 4, "pattern": "all_zeros"},
            {"name": "final_recovery", "duration_frames": 10, "pattern": "convergence"}
        ]
        self.current_phase_index = 0
        self.frames_in_current_phase = 0
        
    def generate_target_coordinates(self) -> Dict[str, float]:
        """Generate single test target coordinates"""
        # Fixed test target for consistent testing
        ra_hours = 12.458  # 12h 27m
        dec_deg = -59.580   # -59¬∞ 35'
        
        return {
            "ra_hours": ra_hours,
            "dec_deg": dec_deg,
            "ra_deg": ra_hours * 15.0
        }
    
    def start_new_target(self):
        """Start the test target"""
        coords = self.generate_target_coordinates()
        self.current_target = coords
        self.target_start_time = time.time()
        self.frame_counter = 0
        self.phase_counter = 0
        self.current_phase_index = 0
        self.frames_in_current_phase = 0
        
        # Write target to mirror file
        self.write_mirror_json()
        print(f"üéØ Test target: RA={coords['ra_hours']:.3f}h, Dec={coords['dec_deg']:.2f}¬∞")
    
    def write_mirror_json(self):
        """Write mirror telescope JSON with current target"""
        if not self.current_target:
            return
            
        timestamp = datetime.now(timezone.utc)
        
        mirror_data = {
            "latest_move": {
                "timestamp": timestamp.isoformat(),
                "ra_deg": self.current_target["ra_deg"],
                "dec_deg": self.current_target["dec_deg"],
                "source": "adaptive_exposure_test"
            },
            "status": "tracking",
            "last_updated": timestamp.isoformat()
        }
        
        # Atomic write using temp file
        temp_file = MIRROR_JSON.with_suffix('.tmp')
        try:
            with open(temp_file, 'w') as f:
                json.dump(mirror_data, f, indent=2)
            temp_file.replace(MIRROR_JSON)
            print(f"üì° Updated mirror file: {MIRROR_JSON}")
        except Exception as e:
            print(f"‚ùå Error writing mirror file: {e}")
            if temp_file.exists():
                temp_file.unlink()
    
    def get_current_test_phase(self):
        """Get current test phase info"""
        if self.current_phase_index >= len(self.test_phases):
            # Repeat the last phase (normal operation)
            return self.test_phases[-1]
        return self.test_phases[self.current_phase_index]
    
    def advance_test_phase(self):
        """Advance to next test phase if current phase is complete"""
        current_phase = self.get_current_test_phase()
        
        if self.frames_in_current_phase >= current_phase["duration_frames"]:
            self.current_phase_index += 1
            self.frames_in_current_phase = 0
            
            next_phase = self.get_current_test_phase()
            print(f"\nüîÑ Phase transition: {current_phase['name']} ‚Üí {next_phase['name']}")
            print(f"   Expected behavior: {self.get_phase_description(next_phase)}")
    
    def get_phase_description(self, phase):
        """Get human-readable description of what should happen in this phase"""
        descriptions = {
            "initial_failure": "Expect 3 platesolve failures, exposure should increase 10s‚Üí20s‚Üí40s",
            "continued_failure": "More failures at 40s, should increase to 80s‚Üí120s", 
            "recovery": "First successful platesolve, should reset exposure to 10s",
            "normal_operation": "Normal small corrections, exposure stays at 10s",
            "new_failure_cycle": "New failure cycle to test reset behavior",
            "final_recovery": "Gradual convergence to test acquisition completion"
        }
        return descriptions.get(phase["name"], "Normal operation")
    
    def generate_platesolve_offsets(self) -> Dict[str, float]:
        """Generate platesolve offsets based on current test phase"""
        current_phase = self.get_current_test_phase()
        pattern = current_phase["pattern"]
        
        if pattern == "all_zeros":
            # Simulate platesolve failure
            ra_offset = 0.0
            dec_offset = 0.0
            
        elif pattern == "small_offsets":
            # Small but measurable offsets (successful platesolve)
            ra_offset = random.uniform(-1.5, 1.5)  # arcsec
            dec_offset = random.uniform(-1.5, 1.5)
            
        elif pattern == "random_small":
            # Normal small corrections
            ra_offset = random.uniform(-0.8, 0.8)
            dec_offset = random.uniform(-0.8, 0.8)
            
        elif pattern == "convergence":
            # Gradually decreasing offsets to simulate acquisition success
            base_offset = max(0.05, 2.0 - (self.frames_in_current_phase * 0.3))
            ra_offset = random.uniform(-base_offset, base_offset)
            dec_offset = random.uniform(-base_offset, base_offset)
            
        else:
            # Default case
            ra_offset = random.uniform(-1.0, 1.0)
            dec_offset = random.uniform(-1.0, 1.0)
        
        return {
            "ra_offset_arcsec": ra_offset,
            "dec_offset_arcsec": dec_offset,
            "ra_offset_deg": ra_offset / 3600.0,
            "dec_offset_deg": dec_offset / 3600.0
        }
    
    def write_platesolve_json(self, exposure_time: float = 10.0):
        """Write platesolve JSON with test data"""
        if not self.current_target:
            return
            
        offsets = self.generate_platesolve_offsets()
        self.frame_counter += 1
        self.frames_in_current_phase += 1
        
        # Generate realistic filename
        timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"MIRROR_{self.current_target['ra_hours']:.3f}h_{self.current_target['dec_deg']:+.3f}d_C_{timestamp_str}_{exposure_time:g}s_{self.frame_counter:05d}.fits"
        
        # Always use current time for this test
        calc_time = datetime.now(timezone.utc)
        
        platesolve_data = {
            "fitsname": {"0": filename},
            "calctime": {"0": calc_time.isoformat()},
            "ra_offset": {"0": offsets["ra_offset_deg"]},
            "dec_offset": {"0": offsets["dec_offset_deg"]}, 
            "theta_offset": {"0": 0.0},  # No rotation for spectroscopy
            "exptime": {"0": exposure_time},
            "solved": {"0": True if (offsets["ra_offset_deg"] != 0.0 or offsets["dec_offset_deg"] != 0.0) else False},
            "ra_center_deg": {"0": self.current_target["ra_deg"]},
            "dec_center_deg": {"0": self.current_target["dec_deg"]},
            "pixel_scale": {"0": 2.1},  # arcsec/pixel for 294MM
            "image_width": {"0": 1936},
            "image_height": {"0": 1216}
        }
        
        # Atomic write
        temp_file = PLATESOLVE_JSON.with_suffix('.tmp')
        try:
            with open(temp_file, 'w') as f:
                json.dump(platesolve_data, f, indent=2)
            temp_file.replace(PLATESOLVE_JSON)
            
            total_offset = math.sqrt(offsets["ra_offset_arcsec"]**2 + offsets["dec_offset_arcsec"]**2)
            current_phase = self.get_current_test_phase()
            
            if offsets["ra_offset_deg"] == 0.0 and offsets["dec_offset_deg"] == 0.0:
                status = "‚ùå FAIL"
            else:
                status = "‚úÖ SOLVE"
                
            print(f"üì∏ Frame {self.frame_counter:03d} [{current_phase['name']}]: {status} | "
                  f"RA={offsets['ra_offset_arcsec']:+.2f}\", Dec={offsets['dec_offset_arcsec']:+.2f}\", "
                  f"Total={total_offset:.2f}\" | Exp={exposure_time:.1f}s")
            
            # Advance test phase after generating data
            self.advance_test_phase()
                
        except Exception as e:
            print(f"‚ùå Error writing platesolve file: {e}")
            if temp_file.exists():
                temp_file.unlink()
    
    def run_adaptive_exposure_test(self, duration_minutes: float = 10.0, platesolve_interval: float = 15.0):
        """Run adaptive exposure test sequence with longer intervals"""
        print("üß™ Starting Adaptive Exposure Test")
        print(f"Duration: {duration_minutes:.1f} minutes")
        print(f"Platesolve interval: {platesolve_interval:.1f}s (slower for realistic timing)")
        print(f"Platesolve JSON: {PLATESOLVE_JSON}")
        print(f"Mirror JSON: {MIRROR_JSON}")
        print("\n" + "="*80)
        print("EXPECTED TEST SEQUENCE:")
        for i, phase in enumerate(self.test_phases, 1):
            print(f"{i}. {phase['name']}: {self.get_phase_description(phase)}")
        print("="*80)
        
        start_time = time.time()
        end_time = start_time + (duration_minutes * 60)
        last_platesolve = 0
        
        # Start with test target
        self.start_new_target()
        
        try:
            while time.time() < end_time:
                current_time = time.time()
                
                # Generate platesolve data at specified intervals
                if current_time - last_platesolve >= platesolve_interval:
                    # Simulate expected exposure times based on phase
                    current_phase = self.get_current_test_phase()
                    if current_phase["pattern"] == "all_zeros":
                        # Simulate adaptive exposure increases
                        attempt = self.frames_in_current_phase + 1
                        exposure_time = min(120.0, 10.0 * (2.0 ** (attempt - 1)))
                    else:
                        # Normal or successful exposure
                        exposure_time = 10.0  # Should reset after success
                    
                    self.write_platesolve_json(exposure_time)
                    last_platesolve = current_time
                
                time.sleep(0.5)  # Check twice per second
                
        except KeyboardInterrupt:
            print("\nüõë Test sequence interrupted by user")
        
        elapsed = (time.time() - start_time) / 60
        print(f"\n‚úÖ Adaptive exposure test completed ({elapsed:.1f} minutes)")
        print("üìä Review the logs to verify adaptive exposure behavior worked correctly")

def main():
    parser = argparse.ArgumentParser(description="Adaptive Exposure Test Generator")
    parser.add_argument("--duration", type=float, default=8.0, help="Test duration in minutes")
    parser.add_argument("--platesolve-interval", type=float, default=15.0, 
                       help="Seconds between platesolve updates (longer for realistic testing)")
    args = parser.parse_args()
    
    generator = AdaptiveExposureTestGenerator()
    
    # Ensure directories exist
    PLATESOLVE_JSON.parent.mkdir(parents=True, exist_ok=True)
    MIRROR_JSON.parent.mkdir(parents=True, exist_ok=True)
    
    generator.run_adaptive_exposure_test(args.duration, args.platesolve_interval)

if __name__ == "__main__":
    main()
